{"ast":null,"code":"import _classCallCheck from \"C:/Users/jared/PortfolioProjects/BookwormSE/Develop/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/jared/PortfolioProjects/BookwormSE/Develop/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { isNode } from '../language/ast.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport { getEnterLeaveForKind } from '../language/visitor.mjs';\nimport { getNamedType, getNullableType, isCompositeType, isEnumType, isInputObjectType, isInputType, isInterfaceType, isListType, isObjectType, isOutputType } from '../type/definition.mjs';\nimport { SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef } from '../type/introspection.mjs';\nimport { typeFromAST } from './typeFromAST.mjs';\n/**\r\n * TypeInfo is a utility class which, given a GraphQL schema, can keep track\r\n * of the current field and type definitions at any point in a GraphQL document\r\n * AST during a recursive descent by calling `enter(node)` and `leave(node)`.\r\n */\n\nexport var TypeInfo = /*#__PURE__*/function (_Symbol$toStringTag) {\n  function TypeInfo(schema,\n  /**\r\n   * Initial type may be provided in rare cases to facilitate traversals\r\n   *  beginning somewhere other than documents.\r\n   */\n  initialType, /** @deprecated will be removed in 17.0.0 */\n  getFieldDefFn) {\n    _classCallCheck(this, TypeInfo);\n    this._schema = schema;\n    this._typeStack = [];\n    this._parentTypeStack = [];\n    this._inputTypeStack = [];\n    this._fieldDefStack = [];\n    this._defaultValueStack = [];\n    this._directive = null;\n    this._argument = null;\n    this._enumValue = null;\n    this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef;\n    if (initialType) {\n      if (isInputType(initialType)) {\n        this._inputTypeStack.push(initialType);\n      }\n      if (isCompositeType(initialType)) {\n        this._parentTypeStack.push(initialType);\n      }\n      if (isOutputType(initialType)) {\n        this._typeStack.push(initialType);\n      }\n    }\n  }\n  _createClass(TypeInfo, [{\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return 'TypeInfo';\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      if (this._typeStack.length > 0) {\n        return this._typeStack[this._typeStack.length - 1];\n      }\n    }\n  }, {\n    key: \"getParentType\",\n    value: function getParentType() {\n      if (this._parentTypeStack.length > 0) {\n        return this._parentTypeStack[this._parentTypeStack.length - 1];\n      }\n    }\n  }, {\n    key: \"getInputType\",\n    value: function getInputType() {\n      if (this._inputTypeStack.length > 0) {\n        return this._inputTypeStack[this._inputTypeStack.length - 1];\n      }\n    }\n  }, {\n    key: \"getParentInputType\",\n    value: function getParentInputType() {\n      if (this._inputTypeStack.length > 1) {\n        return this._inputTypeStack[this._inputTypeStack.length - 2];\n      }\n    }\n  }, {\n    key: \"getFieldDef\",\n    value: function getFieldDef() {\n      if (this._fieldDefStack.length > 0) {\n        return this._fieldDefStack[this._fieldDefStack.length - 1];\n      }\n    }\n  }, {\n    key: \"getDefaultValue\",\n    value: function getDefaultValue() {\n      if (this._defaultValueStack.length > 0) {\n        return this._defaultValueStack[this._defaultValueStack.length - 1];\n      }\n    }\n  }, {\n    key: \"getDirective\",\n    value: function getDirective() {\n      return this._directive;\n    }\n  }, {\n    key: \"getArgument\",\n    value: function getArgument() {\n      return this._argument;\n    }\n  }, {\n    key: \"getEnumValue\",\n    value: function getEnumValue() {\n      return this._enumValue;\n    }\n  }, {\n    key: \"enter\",\n    value: function enter(node) {\n      var schema = this._schema; // Note: many of the types below are explicitly typed as \"unknown\" to drop\n      // any assumptions of a valid schema to ensure runtime types are properly\n      // checked before continuing since TypeInfo is used as part of validation\n      // which occurs before guarantees of schema and document validity.\n\n      switch (node.kind) {\n        case Kind.SELECTION_SET:\n          {\n            var namedType = getNamedType(this.getType());\n            this._parentTypeStack.push(isCompositeType(namedType) ? namedType : undefined);\n            break;\n          }\n        case Kind.FIELD:\n          {\n            var parentType = this.getParentType();\n            var fieldDef;\n            var fieldType;\n            if (parentType) {\n              fieldDef = this._getFieldDef(schema, parentType, node);\n              if (fieldDef) {\n                fieldType = fieldDef.type;\n              }\n            }\n            this._fieldDefStack.push(fieldDef);\n            this._typeStack.push(isOutputType(fieldType) ? fieldType : undefined);\n            break;\n          }\n        case Kind.DIRECTIVE:\n          this._directive = schema.getDirective(node.name.value);\n          break;\n        case Kind.OPERATION_DEFINITION:\n          {\n            var rootType = schema.getRootType(node.operation);\n            this._typeStack.push(isObjectType(rootType) ? rootType : undefined);\n            break;\n          }\n        case Kind.INLINE_FRAGMENT:\n        case Kind.FRAGMENT_DEFINITION:\n          {\n            var typeConditionAST = node.typeCondition;\n            var outputType = typeConditionAST ? typeFromAST(schema, typeConditionAST) : getNamedType(this.getType());\n            this._typeStack.push(isOutputType(outputType) ? outputType : undefined);\n            break;\n          }\n        case Kind.VARIABLE_DEFINITION:\n          {\n            var inputType = typeFromAST(schema, node.type);\n            this._inputTypeStack.push(isInputType(inputType) ? inputType : undefined);\n            break;\n          }\n        case Kind.ARGUMENT:\n          {\n            var _this$getDirective;\n            var argDef;\n            var argType;\n            var fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();\n            if (fieldOrDirective) {\n              argDef = fieldOrDirective.args.find(function (arg) {\n                return arg.name === node.name.value;\n              });\n              if (argDef) {\n                argType = argDef.type;\n              }\n            }\n            this._argument = argDef;\n            this._defaultValueStack.push(argDef ? argDef.defaultValue : undefined);\n            this._inputTypeStack.push(isInputType(argType) ? argType : undefined);\n            break;\n          }\n        case Kind.LIST:\n          {\n            var listType = getNullableType(this.getInputType());\n            var itemType = isListType(listType) ? listType.ofType : listType; // List positions never have a default value.\n\n            this._defaultValueStack.push(undefined);\n            this._inputTypeStack.push(isInputType(itemType) ? itemType : undefined);\n            break;\n          }\n        case Kind.OBJECT_FIELD:\n          {\n            var objectType = getNamedType(this.getInputType());\n            var inputFieldType;\n            var inputField;\n            if (isInputObjectType(objectType)) {\n              inputField = objectType.getFields()[node.name.value];\n              if (inputField) {\n                inputFieldType = inputField.type;\n              }\n            }\n            this._defaultValueStack.push(inputField ? inputField.defaultValue : undefined);\n            this._inputTypeStack.push(isInputType(inputFieldType) ? inputFieldType : undefined);\n            break;\n          }\n        case Kind.ENUM:\n          {\n            var enumType = getNamedType(this.getInputType());\n            var enumValue;\n            if (isEnumType(enumType)) {\n              enumValue = enumType.getValue(node.value);\n            }\n            this._enumValue = enumValue;\n            break;\n          }\n        default: // Ignore other nodes\n      }\n    }\n  }, {\n    key: \"leave\",\n    value: function leave(node) {\n      switch (node.kind) {\n        case Kind.SELECTION_SET:\n          this._parentTypeStack.pop();\n          break;\n        case Kind.FIELD:\n          this._fieldDefStack.pop();\n          this._typeStack.pop();\n          break;\n        case Kind.DIRECTIVE:\n          this._directive = null;\n          break;\n        case Kind.OPERATION_DEFINITION:\n        case Kind.INLINE_FRAGMENT:\n        case Kind.FRAGMENT_DEFINITION:\n          this._typeStack.pop();\n          break;\n        case Kind.VARIABLE_DEFINITION:\n          this._inputTypeStack.pop();\n          break;\n        case Kind.ARGUMENT:\n          this._argument = null;\n          this._defaultValueStack.pop();\n          this._inputTypeStack.pop();\n          break;\n        case Kind.LIST:\n        case Kind.OBJECT_FIELD:\n          this._defaultValueStack.pop();\n          this._inputTypeStack.pop();\n          break;\n        case Kind.ENUM:\n          this._enumValue = null;\n          break;\n        default: // Ignore other nodes\n      }\n    }\n  }]);\n  return TypeInfo;\n}(Symbol.toStringTag);\n\n/**\r\n * Not exactly the same as the executor's definition of getFieldDef, in this\r\n * statically evaluated environment we do not always have an Object type,\r\n * and need to handle Interface and Union types.\r\n */\nfunction getFieldDef(schema, parentType, fieldNode) {\n  var name = fieldNode.name.value;\n  if (name === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return SchemaMetaFieldDef;\n  }\n  if (name === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return TypeMetaFieldDef;\n  }\n  if (name === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {\n    return TypeNameMetaFieldDef;\n  }\n  if (isObjectType(parentType) || isInterfaceType(parentType)) {\n    return parentType.getFields()[name];\n  }\n}\n/**\r\n * Creates a new visitor instance which maintains a provided TypeInfo instance\r\n * along with visiting visitor.\r\n */\n\nexport function visitWithTypeInfo(typeInfo, visitor) {\n  return {\n    enter: function enter() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      var node = args[0];\n      typeInfo.enter(node);\n      var fn = getEnterLeaveForKind(visitor, node.kind).enter;\n      if (fn) {\n        var result = fn.apply(visitor, args);\n        if (result !== undefined) {\n          typeInfo.leave(node);\n          if (isNode(result)) {\n            typeInfo.enter(result);\n          }\n        }\n        return result;\n      }\n    },\n    leave: function leave() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      var node = args[0];\n      var fn = getEnterLeaveForKind(visitor, node.kind).leave;\n      var result;\n      if (fn) {\n        result = fn.apply(visitor, args);\n      }\n      typeInfo.leave(node);\n      return result;\n    }\n  };\n}","map":{"version":3,"names":["isNode","Kind","getEnterLeaveForKind","getNamedType","getNullableType","isCompositeType","isEnumType","isInputObjectType","isInputType","isInterfaceType","isListType","isObjectType","isOutputType","SchemaMetaFieldDef","TypeMetaFieldDef","TypeNameMetaFieldDef","typeFromAST","TypeInfo","_Symbol$toStringTag","schema","initialType","getFieldDefFn","_classCallCheck","_schema","_typeStack","_parentTypeStack","_inputTypeStack","_fieldDefStack","_defaultValueStack","_directive","_argument","_enumValue","_getFieldDef","getFieldDef","push","_createClass","key","get","value","getType","length","getParentType","getInputType","getParentInputType","getDefaultValue","getDirective","getArgument","getEnumValue","enter","node","kind","SELECTION_SET","namedType","undefined","FIELD","parentType","fieldDef","fieldType","type","DIRECTIVE","name","OPERATION_DEFINITION","rootType","getRootType","operation","INLINE_FRAGMENT","FRAGMENT_DEFINITION","typeConditionAST","typeCondition","outputType","VARIABLE_DEFINITION","inputType","ARGUMENT","_this$getDirective","argDef","argType","fieldOrDirective","args","find","arg","defaultValue","LIST","listType","itemType","ofType","OBJECT_FIELD","objectType","inputFieldType","inputField","getFields","ENUM","enumType","enumValue","getValue","leave","pop","Symbol","toStringTag","fieldNode","getQueryType","visitWithTypeInfo","typeInfo","visitor","_len","arguments","Array","_key","fn","result","apply","_len2","_key2"],"sources":["C:/Users/jared/PortfolioProjects/BookwormSE/Develop/client/node_modules/graphql/utilities/TypeInfo.mjs"],"sourcesContent":["import { isNode } from '../language/ast.mjs';\r\nimport { Kind } from '../language/kinds.mjs';\r\nimport { getEnterLeaveForKind } from '../language/visitor.mjs';\r\nimport {\r\n  getNamedType,\r\n  getNullableType,\r\n  isCompositeType,\r\n  isEnumType,\r\n  isInputObjectType,\r\n  isInputType,\r\n  isInterfaceType,\r\n  isListType,\r\n  isObjectType,\r\n  isOutputType,\r\n} from '../type/definition.mjs';\r\nimport {\r\n  SchemaMetaFieldDef,\r\n  TypeMetaFieldDef,\r\n  TypeNameMetaFieldDef,\r\n} from '../type/introspection.mjs';\r\nimport { typeFromAST } from './typeFromAST.mjs';\r\n/**\r\n * TypeInfo is a utility class which, given a GraphQL schema, can keep track\r\n * of the current field and type definitions at any point in a GraphQL document\r\n * AST during a recursive descent by calling `enter(node)` and `leave(node)`.\r\n */\r\n\r\nexport class TypeInfo {\r\n  constructor(\r\n    schema,\r\n    /**\r\n     * Initial type may be provided in rare cases to facilitate traversals\r\n     *  beginning somewhere other than documents.\r\n     */\r\n    initialType,\r\n    /** @deprecated will be removed in 17.0.0 */\r\n    getFieldDefFn,\r\n  ) {\r\n    this._schema = schema;\r\n    this._typeStack = [];\r\n    this._parentTypeStack = [];\r\n    this._inputTypeStack = [];\r\n    this._fieldDefStack = [];\r\n    this._defaultValueStack = [];\r\n    this._directive = null;\r\n    this._argument = null;\r\n    this._enumValue = null;\r\n    this._getFieldDef =\r\n      getFieldDefFn !== null && getFieldDefFn !== void 0\r\n        ? getFieldDefFn\r\n        : getFieldDef;\r\n\r\n    if (initialType) {\r\n      if (isInputType(initialType)) {\r\n        this._inputTypeStack.push(initialType);\r\n      }\r\n\r\n      if (isCompositeType(initialType)) {\r\n        this._parentTypeStack.push(initialType);\r\n      }\r\n\r\n      if (isOutputType(initialType)) {\r\n        this._typeStack.push(initialType);\r\n      }\r\n    }\r\n  }\r\n\r\n  get [Symbol.toStringTag]() {\r\n    return 'TypeInfo';\r\n  }\r\n\r\n  getType() {\r\n    if (this._typeStack.length > 0) {\r\n      return this._typeStack[this._typeStack.length - 1];\r\n    }\r\n  }\r\n\r\n  getParentType() {\r\n    if (this._parentTypeStack.length > 0) {\r\n      return this._parentTypeStack[this._parentTypeStack.length - 1];\r\n    }\r\n  }\r\n\r\n  getInputType() {\r\n    if (this._inputTypeStack.length > 0) {\r\n      return this._inputTypeStack[this._inputTypeStack.length - 1];\r\n    }\r\n  }\r\n\r\n  getParentInputType() {\r\n    if (this._inputTypeStack.length > 1) {\r\n      return this._inputTypeStack[this._inputTypeStack.length - 2];\r\n    }\r\n  }\r\n\r\n  getFieldDef() {\r\n    if (this._fieldDefStack.length > 0) {\r\n      return this._fieldDefStack[this._fieldDefStack.length - 1];\r\n    }\r\n  }\r\n\r\n  getDefaultValue() {\r\n    if (this._defaultValueStack.length > 0) {\r\n      return this._defaultValueStack[this._defaultValueStack.length - 1];\r\n    }\r\n  }\r\n\r\n  getDirective() {\r\n    return this._directive;\r\n  }\r\n\r\n  getArgument() {\r\n    return this._argument;\r\n  }\r\n\r\n  getEnumValue() {\r\n    return this._enumValue;\r\n  }\r\n\r\n  enter(node) {\r\n    const schema = this._schema; // Note: many of the types below are explicitly typed as \"unknown\" to drop\r\n    // any assumptions of a valid schema to ensure runtime types are properly\r\n    // checked before continuing since TypeInfo is used as part of validation\r\n    // which occurs before guarantees of schema and document validity.\r\n\r\n    switch (node.kind) {\r\n      case Kind.SELECTION_SET: {\r\n        const namedType = getNamedType(this.getType());\r\n\r\n        this._parentTypeStack.push(\r\n          isCompositeType(namedType) ? namedType : undefined,\r\n        );\r\n\r\n        break;\r\n      }\r\n\r\n      case Kind.FIELD: {\r\n        const parentType = this.getParentType();\r\n        let fieldDef;\r\n        let fieldType;\r\n\r\n        if (parentType) {\r\n          fieldDef = this._getFieldDef(schema, parentType, node);\r\n\r\n          if (fieldDef) {\r\n            fieldType = fieldDef.type;\r\n          }\r\n        }\r\n\r\n        this._fieldDefStack.push(fieldDef);\r\n\r\n        this._typeStack.push(isOutputType(fieldType) ? fieldType : undefined);\r\n\r\n        break;\r\n      }\r\n\r\n      case Kind.DIRECTIVE:\r\n        this._directive = schema.getDirective(node.name.value);\r\n        break;\r\n\r\n      case Kind.OPERATION_DEFINITION: {\r\n        const rootType = schema.getRootType(node.operation);\r\n\r\n        this._typeStack.push(isObjectType(rootType) ? rootType : undefined);\r\n\r\n        break;\r\n      }\r\n\r\n      case Kind.INLINE_FRAGMENT:\r\n      case Kind.FRAGMENT_DEFINITION: {\r\n        const typeConditionAST = node.typeCondition;\r\n        const outputType = typeConditionAST\r\n          ? typeFromAST(schema, typeConditionAST)\r\n          : getNamedType(this.getType());\r\n\r\n        this._typeStack.push(isOutputType(outputType) ? outputType : undefined);\r\n\r\n        break;\r\n      }\r\n\r\n      case Kind.VARIABLE_DEFINITION: {\r\n        const inputType = typeFromAST(schema, node.type);\r\n\r\n        this._inputTypeStack.push(\r\n          isInputType(inputType) ? inputType : undefined,\r\n        );\r\n\r\n        break;\r\n      }\r\n\r\n      case Kind.ARGUMENT: {\r\n        var _this$getDirective;\r\n\r\n        let argDef;\r\n        let argType;\r\n        const fieldOrDirective =\r\n          (_this$getDirective = this.getDirective()) !== null &&\r\n          _this$getDirective !== void 0\r\n            ? _this$getDirective\r\n            : this.getFieldDef();\r\n\r\n        if (fieldOrDirective) {\r\n          argDef = fieldOrDirective.args.find(\r\n            (arg) => arg.name === node.name.value,\r\n          );\r\n\r\n          if (argDef) {\r\n            argType = argDef.type;\r\n          }\r\n        }\r\n\r\n        this._argument = argDef;\r\n\r\n        this._defaultValueStack.push(argDef ? argDef.defaultValue : undefined);\r\n\r\n        this._inputTypeStack.push(isInputType(argType) ? argType : undefined);\r\n\r\n        break;\r\n      }\r\n\r\n      case Kind.LIST: {\r\n        const listType = getNullableType(this.getInputType());\r\n        const itemType = isListType(listType) ? listType.ofType : listType; // List positions never have a default value.\r\n\r\n        this._defaultValueStack.push(undefined);\r\n\r\n        this._inputTypeStack.push(isInputType(itemType) ? itemType : undefined);\r\n\r\n        break;\r\n      }\r\n\r\n      case Kind.OBJECT_FIELD: {\r\n        const objectType = getNamedType(this.getInputType());\r\n        let inputFieldType;\r\n        let inputField;\r\n\r\n        if (isInputObjectType(objectType)) {\r\n          inputField = objectType.getFields()[node.name.value];\r\n\r\n          if (inputField) {\r\n            inputFieldType = inputField.type;\r\n          }\r\n        }\r\n\r\n        this._defaultValueStack.push(\r\n          inputField ? inputField.defaultValue : undefined,\r\n        );\r\n\r\n        this._inputTypeStack.push(\r\n          isInputType(inputFieldType) ? inputFieldType : undefined,\r\n        );\r\n\r\n        break;\r\n      }\r\n\r\n      case Kind.ENUM: {\r\n        const enumType = getNamedType(this.getInputType());\r\n        let enumValue;\r\n\r\n        if (isEnumType(enumType)) {\r\n          enumValue = enumType.getValue(node.value);\r\n        }\r\n\r\n        this._enumValue = enumValue;\r\n        break;\r\n      }\r\n\r\n      default: // Ignore other nodes\r\n    }\r\n  }\r\n\r\n  leave(node) {\r\n    switch (node.kind) {\r\n      case Kind.SELECTION_SET:\r\n        this._parentTypeStack.pop();\r\n\r\n        break;\r\n\r\n      case Kind.FIELD:\r\n        this._fieldDefStack.pop();\r\n\r\n        this._typeStack.pop();\r\n\r\n        break;\r\n\r\n      case Kind.DIRECTIVE:\r\n        this._directive = null;\r\n        break;\r\n\r\n      case Kind.OPERATION_DEFINITION:\r\n      case Kind.INLINE_FRAGMENT:\r\n      case Kind.FRAGMENT_DEFINITION:\r\n        this._typeStack.pop();\r\n\r\n        break;\r\n\r\n      case Kind.VARIABLE_DEFINITION:\r\n        this._inputTypeStack.pop();\r\n\r\n        break;\r\n\r\n      case Kind.ARGUMENT:\r\n        this._argument = null;\r\n\r\n        this._defaultValueStack.pop();\r\n\r\n        this._inputTypeStack.pop();\r\n\r\n        break;\r\n\r\n      case Kind.LIST:\r\n      case Kind.OBJECT_FIELD:\r\n        this._defaultValueStack.pop();\r\n\r\n        this._inputTypeStack.pop();\r\n\r\n        break;\r\n\r\n      case Kind.ENUM:\r\n        this._enumValue = null;\r\n        break;\r\n\r\n      default: // Ignore other nodes\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Not exactly the same as the executor's definition of getFieldDef, in this\r\n * statically evaluated environment we do not always have an Object type,\r\n * and need to handle Interface and Union types.\r\n */\r\nfunction getFieldDef(schema, parentType, fieldNode) {\r\n  const name = fieldNode.name.value;\r\n\r\n  if (\r\n    name === SchemaMetaFieldDef.name &&\r\n    schema.getQueryType() === parentType\r\n  ) {\r\n    return SchemaMetaFieldDef;\r\n  }\r\n\r\n  if (name === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\r\n    return TypeMetaFieldDef;\r\n  }\r\n\r\n  if (name === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {\r\n    return TypeNameMetaFieldDef;\r\n  }\r\n\r\n  if (isObjectType(parentType) || isInterfaceType(parentType)) {\r\n    return parentType.getFields()[name];\r\n  }\r\n}\r\n/**\r\n * Creates a new visitor instance which maintains a provided TypeInfo instance\r\n * along with visiting visitor.\r\n */\r\n\r\nexport function visitWithTypeInfo(typeInfo, visitor) {\r\n  return {\r\n    enter(...args) {\r\n      const node = args[0];\r\n      typeInfo.enter(node);\r\n      const fn = getEnterLeaveForKind(visitor, node.kind).enter;\r\n\r\n      if (fn) {\r\n        const result = fn.apply(visitor, args);\r\n\r\n        if (result !== undefined) {\r\n          typeInfo.leave(node);\r\n\r\n          if (isNode(result)) {\r\n            typeInfo.enter(result);\r\n          }\r\n        }\r\n\r\n        return result;\r\n      }\r\n    },\r\n\r\n    leave(...args) {\r\n      const node = args[0];\r\n      const fn = getEnterLeaveForKind(visitor, node.kind).leave;\r\n      let result;\r\n\r\n      if (fn) {\r\n        result = fn.apply(visitor, args);\r\n      }\r\n\r\n      typeInfo.leave(node);\r\n      return result;\r\n    },\r\n  };\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}