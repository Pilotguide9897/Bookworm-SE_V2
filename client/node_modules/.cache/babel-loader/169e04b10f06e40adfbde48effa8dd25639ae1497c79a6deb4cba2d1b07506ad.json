{"ast":null,"code":"// A [trie](https://en.wikipedia.org/wiki/Trie) data structure that holds\n// object keys weakly, yet can also hold non-object keys, unlike the\n// native `WeakMap`.\n// If no makeData function is supplied, the looked-up data will be an empty,\n// null-prototype Object.\nconst defaultMakeData = () => Object.create(null);\n// Useful for processing arguments objects as well as arrays.\nconst {\n  forEach,\n  slice\n} = Array.prototype;\nconst {\n  hasOwnProperty\n} = Object.prototype;\nexport class Trie {\n  constructor() {\n    let weakness = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let makeData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultMakeData;\n    this.weakness = weakness;\n    this.makeData = makeData;\n  }\n  lookup() {\n    for (var _len = arguments.length, array = new Array(_len), _key = 0; _key < _len; _key++) {\n      array[_key] = arguments[_key];\n    }\n    return this.lookupArray(array);\n  }\n  lookupArray(array) {\n    let node = this;\n    forEach.call(array, key => node = node.getChildTrie(key));\n    return hasOwnProperty.call(node, \"data\") ? node.data : node.data = this.makeData(slice.call(array));\n  }\n  peek() {\n    for (var _len2 = arguments.length, array = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      array[_key2] = arguments[_key2];\n    }\n    return this.peekArray(array);\n  }\n  peekArray(array) {\n    let node = this;\n    for (let i = 0, len = array.length; node && i < len; ++i) {\n      const map = this.weakness && isObjRef(array[i]) ? node.weak : node.strong;\n      node = map && map.get(array[i]);\n    }\n    return node && node.data;\n  }\n  getChildTrie(key) {\n    const map = this.weakness && isObjRef(key) ? this.weak || (this.weak = new WeakMap()) : this.strong || (this.strong = new Map());\n    let child = map.get(key);\n    if (!child) map.set(key, child = new Trie(this.weakness, this.makeData));\n    return child;\n  }\n}\nfunction isObjRef(value) {\n  switch (typeof value) {\n    case \"object\":\n      if (value === null) break;\n    // Fall through to return true...\n    case \"function\":\n      return true;\n  }\n  return false;\n}","map":{"version":3,"names":["defaultMakeData","Object","create","forEach","slice","Array","prototype","hasOwnProperty","Trie","constructor","weakness","arguments","length","undefined","makeData","lookup","_len","array","_key","lookupArray","node","call","key","getChildTrie","data","peek","_len2","_key2","peekArray","i","len","map","isObjRef","weak","strong","get","WeakMap","Map","child","set","value"],"sources":["C:\\Users\\jared\\PortfolioProjects\\BookwormSE\\Develop\\client\\node_modules\\@wry\\trie\\src\\index.ts"],"sourcesContent":["// A [trie](https://en.wikipedia.org/wiki/Trie) data structure that holds\r\n// object keys weakly, yet can also hold non-object keys, unlike the\r\n// native `WeakMap`.\r\n\r\n// If no makeData function is supplied, the looked-up data will be an empty,\r\n// null-prototype Object.\r\nconst defaultMakeData = () => Object.create(null);\r\n\r\n// Useful for processing arguments objects as well as arrays.\r\nconst { forEach, slice } = Array.prototype;\r\nconst { hasOwnProperty } = Object.prototype;\r\n\r\nexport class Trie<Data> {\r\n  // Since a `WeakMap` cannot hold primitive values as keys, we need a\r\n  // backup `Map` instance to hold primitive keys. Both `this._weakMap`\r\n  // and `this._strongMap` are lazily initialized.\r\n  private weak?: WeakMap<any, Trie<Data>>;\r\n  private strong?: Map<any, Trie<Data>>;\r\n  private data?: Data;\r\n\r\n  constructor(\r\n    private weakness = true,\r\n    private makeData: (array: any[]) => Data = defaultMakeData,\r\n  ) {}\r\n\r\n  public lookup<T extends any[]>(...array: T): Data {\r\n    return this.lookupArray(array);\r\n  }\r\n\r\n  public lookupArray<T extends IArguments | any[]>(array: T): Data {\r\n    let node: Trie<Data> = this;\r\n    forEach.call(array, key => node = node.getChildTrie(key));\r\n    return hasOwnProperty.call(node, \"data\")\r\n      ? node.data as Data\r\n      : node.data = this.makeData(slice.call(array));\r\n  }\r\n\r\n  public peek<T extends any[]>(...array: T): Data | undefined {\r\n    return this.peekArray(array);\r\n  }\r\n\r\n  public peekArray<T extends IArguments | any[]>(array: T): Data | undefined {\r\n    let node: Trie<Data> | undefined = this;\r\n\r\n    for (let i = 0, len = array.length; node && i < len; ++i) {\r\n      const map: Trie<Data>[\"weak\" | \"strong\"] =\r\n        this.weakness && isObjRef(array[i]) ? node.weak : node.strong;\r\n\r\n      node = map && map.get(array[i]);\r\n    }\r\n\r\n    return node && node.data;\r\n  }\r\n\r\n  private getChildTrie(key: any) {\r\n    const map = this.weakness && isObjRef(key)\r\n      ? this.weak || (this.weak = new WeakMap<any, Trie<Data>>())\r\n      : this.strong || (this.strong = new Map<any, Trie<Data>>());\r\n    let child = map.get(key);\r\n    if (!child) map.set(key, child = new Trie<Data>(this.weakness, this.makeData));\r\n    return child;\r\n  }\r\n}\r\n\r\nfunction isObjRef(value: any) {\r\n  switch (typeof value) {\r\n  case \"object\":\r\n    if (value === null) break;\r\n    // Fall through to return true...\r\n  case \"function\":\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AAEA;AACA;AACA,MAAMA,eAAe,GAAGA,CAAA,KAAMC,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;AAEjD;AACA,MAAM;EAAEC,OAAO;EAAEC;AAAK,CAAE,GAAGC,KAAK,CAACC,SAAS;AAC1C,MAAM;EAAEC;AAAc,CAAE,GAAGN,MAAM,CAACK,SAAS;AAE3C,OAAM,MAAOE,IAAI;EAQfC,YAAA,EAE4D;IAAA,IADlDC,QAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAW,IAAI;IAAA,IACfG,QAAA,GAAAH,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAmCX,eAAe;IADlD,KAAAU,QAAQ,GAARA,QAAQ;IACR,KAAAI,QAAQ,GAARA,QAAQ;EACf;EAEIC,MAAMA,CAAA,EAA6B;IAAA,SAAAC,IAAA,GAAAL,SAAA,CAAAC,MAAA,EAARK,KAAQ,OAAAZ,KAAA,CAAAW,IAAA,GAAAE,IAAA,MAAAA,IAAA,GAAAF,IAAA,EAAAE,IAAA;MAARD,KAAQ,CAAAC,IAAA,IAAAP,SAAA,CAAAO,IAAA;IAAA;IACxC,OAAO,IAAI,CAACC,WAAW,CAACF,KAAK,CAAC;EAChC;EAEOE,WAAWA,CAA+BF,KAAQ;IACvD,IAAIG,IAAI,GAAe,IAAI;IAC3BjB,OAAO,CAACkB,IAAI,CAACJ,KAAK,EAAEK,GAAG,IAAIF,IAAI,GAAGA,IAAI,CAACG,YAAY,CAACD,GAAG,CAAC,CAAC;IACzD,OAAOf,cAAc,CAACc,IAAI,CAACD,IAAI,EAAE,MAAM,CAAC,GACpCA,IAAI,CAACI,IAAY,GACjBJ,IAAI,CAACI,IAAI,GAAG,IAAI,CAACV,QAAQ,CAACV,KAAK,CAACiB,IAAI,CAACJ,KAAK,CAAC,CAAC;EAClD;EAEOQ,IAAIA,CAAA,EAA6B;IAAA,SAAAC,KAAA,GAAAf,SAAA,CAAAC,MAAA,EAARK,KAAQ,OAAAZ,KAAA,CAAAqB,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;MAARV,KAAQ,CAAAU,KAAA,IAAAhB,SAAA,CAAAgB,KAAA;IAAA;IACtC,OAAO,IAAI,CAACC,SAAS,CAACX,KAAK,CAAC;EAC9B;EAEOW,SAASA,CAA+BX,KAAQ;IACrD,IAAIG,IAAI,GAA2B,IAAI;IAEvC,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGb,KAAK,CAACL,MAAM,EAAEQ,IAAI,IAAIS,CAAC,GAAGC,GAAG,EAAE,EAAED,CAAC,EAAE;MACxD,MAAME,GAAG,GACP,IAAI,CAACrB,QAAQ,IAAIsB,QAAQ,CAACf,KAAK,CAACY,CAAC,CAAC,CAAC,GAAGT,IAAI,CAACa,IAAI,GAAGb,IAAI,CAACc,MAAM;MAE/Dd,IAAI,GAAGW,GAAG,IAAIA,GAAG,CAACI,GAAG,CAAClB,KAAK,CAACY,CAAC,CAAC,CAAC;;IAGjC,OAAOT,IAAI,IAAIA,IAAI,CAACI,IAAI;EAC1B;EAEQD,YAAYA,CAACD,GAAQ;IAC3B,MAAMS,GAAG,GAAG,IAAI,CAACrB,QAAQ,IAAIsB,QAAQ,CAACV,GAAG,CAAC,GACtC,IAAI,CAACW,IAAI,KAAK,IAAI,CAACA,IAAI,GAAG,IAAIG,OAAO,EAAmB,CAAC,GACzD,IAAI,CAACF,MAAM,KAAK,IAAI,CAACA,MAAM,GAAG,IAAIG,GAAG,EAAmB,CAAC;IAC7D,IAAIC,KAAK,GAAGP,GAAG,CAACI,GAAG,CAACb,GAAG,CAAC;IACxB,IAAI,CAACgB,KAAK,EAAEP,GAAG,CAACQ,GAAG,CAACjB,GAAG,EAAEgB,KAAK,GAAG,IAAI9B,IAAI,CAAO,IAAI,CAACE,QAAQ,EAAE,IAAI,CAACI,QAAQ,CAAC,CAAC;IAC9E,OAAOwB,KAAK;EACd;;AAGF,SAASN,QAAQA,CAACQ,KAAU;EAC1B,QAAQ,OAAOA,KAAK;IACpB,KAAK,QAAQ;MACX,IAAIA,KAAK,KAAK,IAAI,EAAE;IACpB;IACF,KAAK,UAAU;MACb,OAAO,IAAI;;EAEb,OAAO,KAAK;AACd"},"metadata":{},"sourceType":"module","externalDependencies":[]}