{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/jared/PortfolioProjects/BookwormSE/Develop/client/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"C:/Users/jared/PortfolioProjects/BookwormSE/Develop/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/jared/PortfolioProjects/BookwormSE/Develop/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { instanceOf } from '../jsutils/instanceOf.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { toObjMap } from '../jsutils/toObjMap.mjs';\nimport { OperationTypeNode } from '../language/ast.mjs';\nimport { getNamedType, isInputObjectType, isInterfaceType, isObjectType, isUnionType } from './definition.mjs';\nimport { isDirective, specifiedDirectives } from './directives.mjs';\nimport { __Schema } from './introspection.mjs';\n/**\r\n * Test if the given value is a GraphQL schema.\r\n */\n\nexport function isSchema(schema) {\n  return instanceOf(schema, GraphQLSchema);\n}\nexport function assertSchema(schema) {\n  if (!isSchema(schema)) {\n    throw new Error(\"Expected \".concat(inspect(schema), \" to be a GraphQL schema.\"));\n  }\n  return schema;\n}\n/**\r\n * Custom extensions\r\n *\r\n * @remarks\r\n * Use a unique identifier name for your extension, for example the name of\r\n * your library or project. Do not use a shortened identifier as this increases\r\n * the risk of conflicts. We recommend you add at most one extension field,\r\n * an object which can contain all the values you need.\r\n */\n\n/**\r\n * Schema Definition\r\n *\r\n * A Schema is created by supplying the root types of each type of operation,\r\n * query and mutation (optional). A schema definition is then supplied to the\r\n * validator and executor.\r\n *\r\n * Example:\r\n *\r\n * ```ts\r\n * const MyAppSchema = new GraphQLSchema({\r\n *   query: MyAppQueryRootType,\r\n *   mutation: MyAppMutationRootType,\r\n * })\r\n * ```\r\n *\r\n * Note: When the schema is constructed, by default only the types that are\r\n * reachable by traversing the root types are included, other types must be\r\n * explicitly referenced.\r\n *\r\n * Example:\r\n *\r\n * ```ts\r\n * const characterInterface = new GraphQLInterfaceType({\r\n *   name: 'Character',\r\n *   ...\r\n * });\r\n *\r\n * const humanType = new GraphQLObjectType({\r\n *   name: 'Human',\r\n *   interfaces: [characterInterface],\r\n *   ...\r\n * });\r\n *\r\n * const droidType = new GraphQLObjectType({\r\n *   name: 'Droid',\r\n *   interfaces: [characterInterface],\r\n *   ...\r\n * });\r\n *\r\n * const schema = new GraphQLSchema({\r\n *   query: new GraphQLObjectType({\r\n *     name: 'Query',\r\n *     fields: {\r\n *       hero: { type: characterInterface, ... },\r\n *     }\r\n *   }),\r\n *   ...\r\n *   // Since this schema references only the `Character` interface it's\r\n *   // necessary to explicitly list the types that implement it if\r\n *   // you want them to be included in the final schema.\r\n *   types: [humanType, droidType],\r\n * })\r\n * ```\r\n *\r\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\r\n * the exact list of directives represented and allowed. If `directives` is not\r\n * provided then a default set of the specified directives (e.g. `@include` and\r\n * `@skip`) will be used. If you wish to provide *additional* directives to these\r\n * specified directives, you must explicitly declare them. Example:\r\n *\r\n * ```ts\r\n * const MyAppSchema = new GraphQLSchema({\r\n *   ...\r\n *   directives: specifiedDirectives.concat([ myCustomDirective ]),\r\n * })\r\n * ```\r\n */\nexport var GraphQLSchema = /*#__PURE__*/function (_Symbol$toStringTag) {\n  // Used as a cache for validateSchema().\n  function GraphQLSchema(config) {\n    _classCallCheck(this, GraphQLSchema);\n    var _config$extensionASTN, _config$directives;\n\n    // If this schema was built from a source known to be valid, then it may be\n    // marked with assumeValid to avoid an additional type system validation.\n    this.__validationErrors = config.assumeValid === true ? [] : undefined; // Check for common mistakes during construction to produce early errors.\n\n    isObjectLike(config) || devAssert(false, 'Must provide configuration object.');\n    !config.types || Array.isArray(config.types) || devAssert(false, \"\\\"types\\\" must be Array if provided but got: \".concat(inspect(config.types), \".\"));\n    !config.directives || Array.isArray(config.directives) || devAssert(false, '\"directives\" must be Array if provided but got: ' + \"\".concat(inspect(config.directives), \".\"));\n    this.description = config.description;\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];\n    this._queryType = config.query;\n    this._mutationType = config.mutation;\n    this._subscriptionType = config.subscription; // Provide specified directives (e.g. @include and @skip) by default.\n\n    this._directives = (_config$directives = config.directives) !== null && _config$directives !== void 0 ? _config$directives : specifiedDirectives; // To preserve order of user-provided types, we add first to add them to\n    // the set of \"collected\" types, so `collectReferencedTypes` ignore them.\n\n    var allReferencedTypes = new Set(config.types);\n    if (config.types != null) {\n      var _iterator = _createForOfIteratorHelper(config.types),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var type = _step.value;\n          // When we ready to process this type, we remove it from \"collected\" types\n          // and then add it together with all dependent types in the correct position.\n          allReferencedTypes.delete(type);\n          collectReferencedTypes(type, allReferencedTypes);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    if (this._queryType != null) {\n      collectReferencedTypes(this._queryType, allReferencedTypes);\n    }\n    if (this._mutationType != null) {\n      collectReferencedTypes(this._mutationType, allReferencedTypes);\n    }\n    if (this._subscriptionType != null) {\n      collectReferencedTypes(this._subscriptionType, allReferencedTypes);\n    }\n    var _iterator2 = _createForOfIteratorHelper(this._directives),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var directive = _step2.value;\n        // Directives are not validated until validateSchema() is called.\n        if (isDirective(directive)) {\n          var _iterator4 = _createForOfIteratorHelper(directive.args),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var arg = _step4.value;\n              collectReferencedTypes(arg.type, allReferencedTypes);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    collectReferencedTypes(__Schema, allReferencedTypes); // Storing the resulting map for reference by the schema.\n\n    this._typeMap = Object.create(null);\n    this._subTypeMap = Object.create(null); // Keep track of all implementations by interface name.\n\n    this._implementationsMap = Object.create(null);\n    var _iterator3 = _createForOfIteratorHelper(allReferencedTypes),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var namedType = _step3.value;\n        if (namedType == null) {\n          continue;\n        }\n        var typeName = namedType.name;\n        typeName || devAssert(false, 'One of the provided types for building the Schema is missing a name.');\n        if (this._typeMap[typeName] !== undefined) {\n          throw new Error(\"Schema must contain uniquely named types but contains multiple types named \\\"\".concat(typeName, \"\\\".\"));\n        }\n        this._typeMap[typeName] = namedType;\n        if (isInterfaceType(namedType)) {\n          // Store implementations by interface.\n          var _iterator5 = _createForOfIteratorHelper(namedType.getInterfaces()),\n            _step5;\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var iface = _step5.value;\n              if (isInterfaceType(iface)) {\n                var implementations = this._implementationsMap[iface.name];\n                if (implementations === undefined) {\n                  implementations = this._implementationsMap[iface.name] = {\n                    objects: [],\n                    interfaces: []\n                  };\n                }\n                implementations.interfaces.push(namedType);\n              }\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        } else if (isObjectType(namedType)) {\n          // Store implementations by objects.\n          var _iterator6 = _createForOfIteratorHelper(namedType.getInterfaces()),\n            _step6;\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var _iface = _step6.value;\n              if (isInterfaceType(_iface)) {\n                var _implementations = this._implementationsMap[_iface.name];\n                if (_implementations === undefined) {\n                  _implementations = this._implementationsMap[_iface.name] = {\n                    objects: [],\n                    interfaces: []\n                  };\n                }\n                _implementations.objects.push(namedType);\n              }\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  }\n  _createClass(GraphQLSchema, [{\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return 'GraphQLSchema';\n    }\n  }, {\n    key: \"getQueryType\",\n    value: function getQueryType() {\n      return this._queryType;\n    }\n  }, {\n    key: \"getMutationType\",\n    value: function getMutationType() {\n      return this._mutationType;\n    }\n  }, {\n    key: \"getSubscriptionType\",\n    value: function getSubscriptionType() {\n      return this._subscriptionType;\n    }\n  }, {\n    key: \"getRootType\",\n    value: function getRootType(operation) {\n      switch (operation) {\n        case OperationTypeNode.QUERY:\n          return this.getQueryType();\n        case OperationTypeNode.MUTATION:\n          return this.getMutationType();\n        case OperationTypeNode.SUBSCRIPTION:\n          return this.getSubscriptionType();\n      }\n    }\n  }, {\n    key: \"getTypeMap\",\n    value: function getTypeMap() {\n      return this._typeMap;\n    }\n  }, {\n    key: \"getType\",\n    value: function getType(name) {\n      return this.getTypeMap()[name];\n    }\n  }, {\n    key: \"getPossibleTypes\",\n    value: function getPossibleTypes(abstractType) {\n      return isUnionType(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;\n    }\n  }, {\n    key: \"getImplementations\",\n    value: function getImplementations(interfaceType) {\n      var implementations = this._implementationsMap[interfaceType.name];\n      return implementations !== null && implementations !== void 0 ? implementations : {\n        objects: [],\n        interfaces: []\n      };\n    }\n  }, {\n    key: \"isSubType\",\n    value: function isSubType(abstractType, maybeSubType) {\n      var map = this._subTypeMap[abstractType.name];\n      if (map === undefined) {\n        map = Object.create(null);\n        if (isUnionType(abstractType)) {\n          var _iterator7 = _createForOfIteratorHelper(abstractType.getTypes()),\n            _step7;\n          try {\n            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n              var type = _step7.value;\n              map[type.name] = true;\n            }\n          } catch (err) {\n            _iterator7.e(err);\n          } finally {\n            _iterator7.f();\n          }\n        } else {\n          var implementations = this.getImplementations(abstractType);\n          var _iterator8 = _createForOfIteratorHelper(implementations.objects),\n            _step8;\n          try {\n            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n              var _type = _step8.value;\n              map[_type.name] = true;\n            }\n          } catch (err) {\n            _iterator8.e(err);\n          } finally {\n            _iterator8.f();\n          }\n          var _iterator9 = _createForOfIteratorHelper(implementations.interfaces),\n            _step9;\n          try {\n            for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n              var _type2 = _step9.value;\n              map[_type2.name] = true;\n            }\n          } catch (err) {\n            _iterator9.e(err);\n          } finally {\n            _iterator9.f();\n          }\n        }\n        this._subTypeMap[abstractType.name] = map;\n      }\n      return map[maybeSubType.name] !== undefined;\n    }\n  }, {\n    key: \"getDirectives\",\n    value: function getDirectives() {\n      return this._directives;\n    }\n  }, {\n    key: \"getDirective\",\n    value: function getDirective(name) {\n      return this.getDirectives().find(function (directive) {\n        return directive.name === name;\n      });\n    }\n  }, {\n    key: \"toConfig\",\n    value: function toConfig() {\n      return {\n        description: this.description,\n        query: this.getQueryType(),\n        mutation: this.getMutationType(),\n        subscription: this.getSubscriptionType(),\n        types: Object.values(this.getTypeMap()),\n        directives: this.getDirectives(),\n        extensions: this.extensions,\n        astNode: this.astNode,\n        extensionASTNodes: this.extensionASTNodes,\n        assumeValid: this.__validationErrors !== undefined\n      };\n    }\n  }]);\n  return GraphQLSchema;\n}(Symbol.toStringTag);\nfunction collectReferencedTypes(type, typeSet) {\n  var namedType = getNamedType(type);\n  if (!typeSet.has(namedType)) {\n    typeSet.add(namedType);\n    if (isUnionType(namedType)) {\n      var _iterator10 = _createForOfIteratorHelper(namedType.getTypes()),\n        _step10;\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var memberType = _step10.value;\n          collectReferencedTypes(memberType, typeSet);\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n    } else if (isObjectType(namedType) || isInterfaceType(namedType)) {\n      var _iterator11 = _createForOfIteratorHelper(namedType.getInterfaces()),\n        _step11;\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var interfaceType = _step11.value;\n          collectReferencedTypes(interfaceType, typeSet);\n        }\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n      for (var _i = 0, _Object$values = Object.values(namedType.getFields()); _i < _Object$values.length; _i++) {\n        var field = _Object$values[_i];\n        collectReferencedTypes(field.type, typeSet);\n        var _iterator12 = _createForOfIteratorHelper(field.args),\n          _step12;\n        try {\n          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n            var arg = _step12.value;\n            collectReferencedTypes(arg.type, typeSet);\n          }\n        } catch (err) {\n          _iterator12.e(err);\n        } finally {\n          _iterator12.f();\n        }\n      }\n    } else if (isInputObjectType(namedType)) {\n      for (var _i2 = 0, _Object$values2 = Object.values(namedType.getFields()); _i2 < _Object$values2.length; _i2++) {\n        var _field = _Object$values2[_i2];\n        collectReferencedTypes(_field.type, typeSet);\n      }\n    }\n  }\n  return typeSet;\n}","map":{"version":3,"names":["devAssert","inspect","instanceOf","isObjectLike","toObjMap","OperationTypeNode","getNamedType","isInputObjectType","isInterfaceType","isObjectType","isUnionType","isDirective","specifiedDirectives","__Schema","isSchema","schema","GraphQLSchema","assertSchema","Error","concat","_Symbol$toStringTag","config","_classCallCheck","_config$extensionASTN","_config$directives","__validationErrors","assumeValid","undefined","types","Array","isArray","directives","description","extensions","astNode","extensionASTNodes","_queryType","query","_mutationType","mutation","_subscriptionType","subscription","_directives","allReferencedTypes","Set","_iterator","_createForOfIteratorHelper","_step","s","n","done","type","value","delete","collectReferencedTypes","err","e","f","_iterator2","_step2","directive","_iterator4","args","_step4","arg","_typeMap","Object","create","_subTypeMap","_implementationsMap","_iterator3","_step3","namedType","typeName","name","_iterator5","getInterfaces","_step5","iface","implementations","objects","interfaces","push","_iterator6","_step6","_createClass","key","get","getQueryType","getMutationType","getSubscriptionType","getRootType","operation","QUERY","MUTATION","SUBSCRIPTION","getTypeMap","getType","getPossibleTypes","abstractType","getTypes","getImplementations","interfaceType","isSubType","maybeSubType","map","_iterator7","_step7","_iterator8","_step8","_iterator9","_step9","getDirectives","getDirective","find","toConfig","values","Symbol","toStringTag","typeSet","has","add","_iterator10","_step10","memberType","_iterator11","_step11","_i","_Object$values","getFields","length","field","_iterator12","_step12","_i2","_Object$values2"],"sources":["C:/Users/jared/PortfolioProjects/BookwormSE/Develop/client/node_modules/graphql/type/schema.mjs"],"sourcesContent":["import { devAssert } from '../jsutils/devAssert.mjs';\r\nimport { inspect } from '../jsutils/inspect.mjs';\r\nimport { instanceOf } from '../jsutils/instanceOf.mjs';\r\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\r\nimport { toObjMap } from '../jsutils/toObjMap.mjs';\r\nimport { OperationTypeNode } from '../language/ast.mjs';\r\nimport {\r\n  getNamedType,\r\n  isInputObjectType,\r\n  isInterfaceType,\r\n  isObjectType,\r\n  isUnionType,\r\n} from './definition.mjs';\r\nimport { isDirective, specifiedDirectives } from './directives.mjs';\r\nimport { __Schema } from './introspection.mjs';\r\n/**\r\n * Test if the given value is a GraphQL schema.\r\n */\r\n\r\nexport function isSchema(schema) {\r\n  return instanceOf(schema, GraphQLSchema);\r\n}\r\nexport function assertSchema(schema) {\r\n  if (!isSchema(schema)) {\r\n    throw new Error(`Expected ${inspect(schema)} to be a GraphQL schema.`);\r\n  }\r\n\r\n  return schema;\r\n}\r\n/**\r\n * Custom extensions\r\n *\r\n * @remarks\r\n * Use a unique identifier name for your extension, for example the name of\r\n * your library or project. Do not use a shortened identifier as this increases\r\n * the risk of conflicts. We recommend you add at most one extension field,\r\n * an object which can contain all the values you need.\r\n */\r\n\r\n/**\r\n * Schema Definition\r\n *\r\n * A Schema is created by supplying the root types of each type of operation,\r\n * query and mutation (optional). A schema definition is then supplied to the\r\n * validator and executor.\r\n *\r\n * Example:\r\n *\r\n * ```ts\r\n * const MyAppSchema = new GraphQLSchema({\r\n *   query: MyAppQueryRootType,\r\n *   mutation: MyAppMutationRootType,\r\n * })\r\n * ```\r\n *\r\n * Note: When the schema is constructed, by default only the types that are\r\n * reachable by traversing the root types are included, other types must be\r\n * explicitly referenced.\r\n *\r\n * Example:\r\n *\r\n * ```ts\r\n * const characterInterface = new GraphQLInterfaceType({\r\n *   name: 'Character',\r\n *   ...\r\n * });\r\n *\r\n * const humanType = new GraphQLObjectType({\r\n *   name: 'Human',\r\n *   interfaces: [characterInterface],\r\n *   ...\r\n * });\r\n *\r\n * const droidType = new GraphQLObjectType({\r\n *   name: 'Droid',\r\n *   interfaces: [characterInterface],\r\n *   ...\r\n * });\r\n *\r\n * const schema = new GraphQLSchema({\r\n *   query: new GraphQLObjectType({\r\n *     name: 'Query',\r\n *     fields: {\r\n *       hero: { type: characterInterface, ... },\r\n *     }\r\n *   }),\r\n *   ...\r\n *   // Since this schema references only the `Character` interface it's\r\n *   // necessary to explicitly list the types that implement it if\r\n *   // you want them to be included in the final schema.\r\n *   types: [humanType, droidType],\r\n * })\r\n * ```\r\n *\r\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\r\n * the exact list of directives represented and allowed. If `directives` is not\r\n * provided then a default set of the specified directives (e.g. `@include` and\r\n * `@skip`) will be used. If you wish to provide *additional* directives to these\r\n * specified directives, you must explicitly declare them. Example:\r\n *\r\n * ```ts\r\n * const MyAppSchema = new GraphQLSchema({\r\n *   ...\r\n *   directives: specifiedDirectives.concat([ myCustomDirective ]),\r\n * })\r\n * ```\r\n */\r\nexport class GraphQLSchema {\r\n  // Used as a cache for validateSchema().\r\n  constructor(config) {\r\n    var _config$extensionASTN, _config$directives;\r\n\r\n    // If this schema was built from a source known to be valid, then it may be\r\n    // marked with assumeValid to avoid an additional type system validation.\r\n    this.__validationErrors = config.assumeValid === true ? [] : undefined; // Check for common mistakes during construction to produce early errors.\r\n\r\n    isObjectLike(config) ||\r\n      devAssert(false, 'Must provide configuration object.');\r\n    !config.types ||\r\n      Array.isArray(config.types) ||\r\n      devAssert(\r\n        false,\r\n        `\"types\" must be Array if provided but got: ${inspect(config.types)}.`,\r\n      );\r\n    !config.directives ||\r\n      Array.isArray(config.directives) ||\r\n      devAssert(\r\n        false,\r\n        '\"directives\" must be Array if provided but got: ' +\r\n          `${inspect(config.directives)}.`,\r\n      );\r\n    this.description = config.description;\r\n    this.extensions = toObjMap(config.extensions);\r\n    this.astNode = config.astNode;\r\n    this.extensionASTNodes =\r\n      (_config$extensionASTN = config.extensionASTNodes) !== null &&\r\n      _config$extensionASTN !== void 0\r\n        ? _config$extensionASTN\r\n        : [];\r\n    this._queryType = config.query;\r\n    this._mutationType = config.mutation;\r\n    this._subscriptionType = config.subscription; // Provide specified directives (e.g. @include and @skip) by default.\r\n\r\n    this._directives =\r\n      (_config$directives = config.directives) !== null &&\r\n      _config$directives !== void 0\r\n        ? _config$directives\r\n        : specifiedDirectives; // To preserve order of user-provided types, we add first to add them to\r\n    // the set of \"collected\" types, so `collectReferencedTypes` ignore them.\r\n\r\n    const allReferencedTypes = new Set(config.types);\r\n\r\n    if (config.types != null) {\r\n      for (const type of config.types) {\r\n        // When we ready to process this type, we remove it from \"collected\" types\r\n        // and then add it together with all dependent types in the correct position.\r\n        allReferencedTypes.delete(type);\r\n        collectReferencedTypes(type, allReferencedTypes);\r\n      }\r\n    }\r\n\r\n    if (this._queryType != null) {\r\n      collectReferencedTypes(this._queryType, allReferencedTypes);\r\n    }\r\n\r\n    if (this._mutationType != null) {\r\n      collectReferencedTypes(this._mutationType, allReferencedTypes);\r\n    }\r\n\r\n    if (this._subscriptionType != null) {\r\n      collectReferencedTypes(this._subscriptionType, allReferencedTypes);\r\n    }\r\n\r\n    for (const directive of this._directives) {\r\n      // Directives are not validated until validateSchema() is called.\r\n      if (isDirective(directive)) {\r\n        for (const arg of directive.args) {\r\n          collectReferencedTypes(arg.type, allReferencedTypes);\r\n        }\r\n      }\r\n    }\r\n\r\n    collectReferencedTypes(__Schema, allReferencedTypes); // Storing the resulting map for reference by the schema.\r\n\r\n    this._typeMap = Object.create(null);\r\n    this._subTypeMap = Object.create(null); // Keep track of all implementations by interface name.\r\n\r\n    this._implementationsMap = Object.create(null);\r\n\r\n    for (const namedType of allReferencedTypes) {\r\n      if (namedType == null) {\r\n        continue;\r\n      }\r\n\r\n      const typeName = namedType.name;\r\n      typeName ||\r\n        devAssert(\r\n          false,\r\n          'One of the provided types for building the Schema is missing a name.',\r\n        );\r\n\r\n      if (this._typeMap[typeName] !== undefined) {\r\n        throw new Error(\r\n          `Schema must contain uniquely named types but contains multiple types named \"${typeName}\".`,\r\n        );\r\n      }\r\n\r\n      this._typeMap[typeName] = namedType;\r\n\r\n      if (isInterfaceType(namedType)) {\r\n        // Store implementations by interface.\r\n        for (const iface of namedType.getInterfaces()) {\r\n          if (isInterfaceType(iface)) {\r\n            let implementations = this._implementationsMap[iface.name];\r\n\r\n            if (implementations === undefined) {\r\n              implementations = this._implementationsMap[iface.name] = {\r\n                objects: [],\r\n                interfaces: [],\r\n              };\r\n            }\r\n\r\n            implementations.interfaces.push(namedType);\r\n          }\r\n        }\r\n      } else if (isObjectType(namedType)) {\r\n        // Store implementations by objects.\r\n        for (const iface of namedType.getInterfaces()) {\r\n          if (isInterfaceType(iface)) {\r\n            let implementations = this._implementationsMap[iface.name];\r\n\r\n            if (implementations === undefined) {\r\n              implementations = this._implementationsMap[iface.name] = {\r\n                objects: [],\r\n                interfaces: [],\r\n              };\r\n            }\r\n\r\n            implementations.objects.push(namedType);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  get [Symbol.toStringTag]() {\r\n    return 'GraphQLSchema';\r\n  }\r\n\r\n  getQueryType() {\r\n    return this._queryType;\r\n  }\r\n\r\n  getMutationType() {\r\n    return this._mutationType;\r\n  }\r\n\r\n  getSubscriptionType() {\r\n    return this._subscriptionType;\r\n  }\r\n\r\n  getRootType(operation) {\r\n    switch (operation) {\r\n      case OperationTypeNode.QUERY:\r\n        return this.getQueryType();\r\n\r\n      case OperationTypeNode.MUTATION:\r\n        return this.getMutationType();\r\n\r\n      case OperationTypeNode.SUBSCRIPTION:\r\n        return this.getSubscriptionType();\r\n    }\r\n  }\r\n\r\n  getTypeMap() {\r\n    return this._typeMap;\r\n  }\r\n\r\n  getType(name) {\r\n    return this.getTypeMap()[name];\r\n  }\r\n\r\n  getPossibleTypes(abstractType) {\r\n    return isUnionType(abstractType)\r\n      ? abstractType.getTypes()\r\n      : this.getImplementations(abstractType).objects;\r\n  }\r\n\r\n  getImplementations(interfaceType) {\r\n    const implementations = this._implementationsMap[interfaceType.name];\r\n    return implementations !== null && implementations !== void 0\r\n      ? implementations\r\n      : {\r\n          objects: [],\r\n          interfaces: [],\r\n        };\r\n  }\r\n\r\n  isSubType(abstractType, maybeSubType) {\r\n    let map = this._subTypeMap[abstractType.name];\r\n\r\n    if (map === undefined) {\r\n      map = Object.create(null);\r\n\r\n      if (isUnionType(abstractType)) {\r\n        for (const type of abstractType.getTypes()) {\r\n          map[type.name] = true;\r\n        }\r\n      } else {\r\n        const implementations = this.getImplementations(abstractType);\r\n\r\n        for (const type of implementations.objects) {\r\n          map[type.name] = true;\r\n        }\r\n\r\n        for (const type of implementations.interfaces) {\r\n          map[type.name] = true;\r\n        }\r\n      }\r\n\r\n      this._subTypeMap[abstractType.name] = map;\r\n    }\r\n\r\n    return map[maybeSubType.name] !== undefined;\r\n  }\r\n\r\n  getDirectives() {\r\n    return this._directives;\r\n  }\r\n\r\n  getDirective(name) {\r\n    return this.getDirectives().find((directive) => directive.name === name);\r\n  }\r\n\r\n  toConfig() {\r\n    return {\r\n      description: this.description,\r\n      query: this.getQueryType(),\r\n      mutation: this.getMutationType(),\r\n      subscription: this.getSubscriptionType(),\r\n      types: Object.values(this.getTypeMap()),\r\n      directives: this.getDirectives(),\r\n      extensions: this.extensions,\r\n      astNode: this.astNode,\r\n      extensionASTNodes: this.extensionASTNodes,\r\n      assumeValid: this.__validationErrors !== undefined,\r\n    };\r\n  }\r\n}\r\n\r\nfunction collectReferencedTypes(type, typeSet) {\r\n  const namedType = getNamedType(type);\r\n\r\n  if (!typeSet.has(namedType)) {\r\n    typeSet.add(namedType);\r\n\r\n    if (isUnionType(namedType)) {\r\n      for (const memberType of namedType.getTypes()) {\r\n        collectReferencedTypes(memberType, typeSet);\r\n      }\r\n    } else if (isObjectType(namedType) || isInterfaceType(namedType)) {\r\n      for (const interfaceType of namedType.getInterfaces()) {\r\n        collectReferencedTypes(interfaceType, typeSet);\r\n      }\r\n\r\n      for (const field of Object.values(namedType.getFields())) {\r\n        collectReferencedTypes(field.type, typeSet);\r\n\r\n        for (const arg of field.args) {\r\n          collectReferencedTypes(arg.type, typeSet);\r\n        }\r\n      }\r\n    } else if (isInputObjectType(namedType)) {\r\n      for (const field of Object.values(namedType.getFields())) {\r\n        collectReferencedTypes(field.type, typeSet);\r\n      }\r\n    }\r\n  }\r\n\r\n  return typeSet;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}