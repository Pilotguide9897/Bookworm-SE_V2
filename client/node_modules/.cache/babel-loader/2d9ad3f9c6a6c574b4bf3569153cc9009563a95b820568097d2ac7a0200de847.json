{"ast":null,"code":"import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { isNode, QueryDocumentKeys } from './ast.mjs';\nimport { Kind } from './kinds.mjs';\n/**\r\n * A visitor is provided to visit, it contains the collection of\r\n * relevant functions to be called during the visitor's traversal.\r\n */\n\nexport const BREAK = Object.freeze({});\n/**\r\n * visit() will walk through an AST using a depth-first traversal, calling\r\n * the visitor's enter function at each node in the traversal, and calling the\r\n * leave function after visiting that node and all of its child nodes.\r\n *\r\n * By returning different values from the enter and leave functions, the\r\n * behavior of the visitor can be altered, including skipping over a sub-tree of\r\n * the AST (by returning false), editing the AST by returning a value or null\r\n * to remove the value, or to stop the whole traversal by returning BREAK.\r\n *\r\n * When using visit() to edit an AST, the original AST will not be modified, and\r\n * a new version of the AST with the changes applied will be returned from the\r\n * visit function.\r\n *\r\n * ```ts\r\n * const editedAST = visit(ast, {\r\n *   enter(node, key, parent, path, ancestors) {\r\n *     // @return\r\n *     //   undefined: no action\r\n *     //   false: skip visiting this node\r\n *     //   visitor.BREAK: stop visiting altogether\r\n *     //   null: delete this node\r\n *     //   any value: replace this node with the returned value\r\n *   },\r\n *   leave(node, key, parent, path, ancestors) {\r\n *     // @return\r\n *     //   undefined: no action\r\n *     //   false: no action\r\n *     //   visitor.BREAK: stop visiting altogether\r\n *     //   null: delete this node\r\n *     //   any value: replace this node with the returned value\r\n *   }\r\n * });\r\n * ```\r\n *\r\n * Alternatively to providing enter() and leave() functions, a visitor can\r\n * instead provide functions named the same as the kinds of AST nodes, or\r\n * enter/leave visitors at a named key, leading to three permutations of the\r\n * visitor API:\r\n *\r\n * 1) Named visitors triggered when entering a node of a specific kind.\r\n *\r\n * ```ts\r\n * visit(ast, {\r\n *   Kind(node) {\r\n *     // enter the \"Kind\" node\r\n *   }\r\n * })\r\n * ```\r\n *\r\n * 2) Named visitors that trigger upon entering and leaving a node of a specific kind.\r\n *\r\n * ```ts\r\n * visit(ast, {\r\n *   Kind: {\r\n *     enter(node) {\r\n *       // enter the \"Kind\" node\r\n *     }\r\n *     leave(node) {\r\n *       // leave the \"Kind\" node\r\n *     }\r\n *   }\r\n * })\r\n * ```\r\n *\r\n * 3) Generic visitors that trigger upon entering and leaving any node.\r\n *\r\n * ```ts\r\n * visit(ast, {\r\n *   enter(node) {\r\n *     // enter any node\r\n *   },\r\n *   leave(node) {\r\n *     // leave any node\r\n *   }\r\n * })\r\n * ```\r\n */\n\nexport function visit(root, visitor) {\n  let visitorKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : QueryDocumentKeys;\n  const enterLeaveMap = new Map();\n  for (const kind of Object.values(Kind)) {\n    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));\n  }\n  /* eslint-disable no-undef-init */\n\n  let stack = undefined;\n  let inArray = Array.isArray(root);\n  let keys = [root];\n  let index = -1;\n  let edits = [];\n  let node = root;\n  let key = undefined;\n  let parent = undefined;\n  const path = [];\n  const ancestors = [];\n  /* eslint-enable no-undef-init */\n\n  do {\n    index++;\n    const isLeaving = index === keys.length;\n    const isEdited = isLeaving && edits.length !== 0;\n    if (isLeaving) {\n      key = ancestors.length === 0 ? undefined : path[path.length - 1];\n      node = parent;\n      parent = ancestors.pop();\n      if (isEdited) {\n        if (inArray) {\n          node = node.slice();\n          let editOffset = 0;\n          for (const [editKey, editValue] of edits) {\n            const arrayKey = editKey - editOffset;\n            if (editValue === null) {\n              node.splice(arrayKey, 1);\n              editOffset++;\n            } else {\n              node[arrayKey] = editValue;\n            }\n          }\n        } else {\n          node = Object.defineProperties({}, Object.getOwnPropertyDescriptors(node));\n          for (const [editKey, editValue] of edits) {\n            node[editKey] = editValue;\n          }\n        }\n      }\n      index = stack.index;\n      keys = stack.keys;\n      edits = stack.edits;\n      inArray = stack.inArray;\n      stack = stack.prev;\n    } else if (parent) {\n      key = inArray ? index : keys[index];\n      node = parent[key];\n      if (node === null || node === undefined) {\n        continue;\n      }\n      path.push(key);\n    }\n    let result;\n    if (!Array.isArray(node)) {\n      var _enterLeaveMap$get, _enterLeaveMap$get2;\n      isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);\n      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;\n      result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);\n      if (result === BREAK) {\n        break;\n      }\n      if (result === false) {\n        if (!isLeaving) {\n          path.pop();\n          continue;\n        }\n      } else if (result !== undefined) {\n        edits.push([key, result]);\n        if (!isLeaving) {\n          if (isNode(result)) {\n            node = result;\n          } else {\n            path.pop();\n            continue;\n          }\n        }\n      }\n    }\n    if (result === undefined && isEdited) {\n      edits.push([key, node]);\n    }\n    if (isLeaving) {\n      path.pop();\n    } else {\n      var _node$kind;\n      stack = {\n        inArray,\n        index,\n        keys,\n        edits,\n        prev: stack\n      };\n      inArray = Array.isArray(node);\n      keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];\n      index = -1;\n      edits = [];\n      if (parent) {\n        ancestors.push(parent);\n      }\n      parent = node;\n    }\n  } while (stack !== undefined);\n  if (edits.length !== 0) {\n    // New root\n    return edits[edits.length - 1][1];\n  }\n  return root;\n}\n/**\r\n * Creates a new visitor instance which delegates to many visitors to run in\r\n * parallel. Each visitor will be visited for each node before moving on.\r\n *\r\n * If a prior visitor edits a node, no following visitors will see that node.\r\n */\n\nexport function visitInParallel(visitors) {\n  const skipping = new Array(visitors.length).fill(null);\n  const mergedVisitor = Object.create(null);\n  for (const kind of Object.values(Kind)) {\n    let hasVisitor = false;\n    const enterList = new Array(visitors.length).fill(undefined);\n    const leaveList = new Array(visitors.length).fill(undefined);\n    for (let i = 0; i < visitors.length; ++i) {\n      const {\n        enter,\n        leave\n      } = getEnterLeaveForKind(visitors[i], kind);\n      hasVisitor || (hasVisitor = enter != null || leave != null);\n      enterList[i] = enter;\n      leaveList[i] = leave;\n    }\n    if (!hasVisitor) {\n      continue;\n    }\n    const mergedEnterLeave = {\n      enter() {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        const node = args[0];\n        for (let i = 0; i < visitors.length; i++) {\n          if (skipping[i] === null) {\n            var _enterList$i;\n            const result = (_enterList$i = enterList[i]) === null || _enterList$i === void 0 ? void 0 : _enterList$i.apply(visitors[i], args);\n            if (result === false) {\n              skipping[i] = node;\n            } else if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined) {\n              return result;\n            }\n          }\n        }\n      },\n      leave() {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n        const node = args[0];\n        for (let i = 0; i < visitors.length; i++) {\n          if (skipping[i] === null) {\n            var _leaveList$i;\n            const result = (_leaveList$i = leaveList[i]) === null || _leaveList$i === void 0 ? void 0 : _leaveList$i.apply(visitors[i], args);\n            if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined && result !== false) {\n              return result;\n            }\n          } else if (skipping[i] === node) {\n            skipping[i] = null;\n          }\n        }\n      }\n    };\n    mergedVisitor[kind] = mergedEnterLeave;\n  }\n  return mergedVisitor;\n}\n/**\r\n * Given a visitor instance and a node kind, return EnterLeaveVisitor for that kind.\r\n */\n\nexport function getEnterLeaveForKind(visitor, kind) {\n  const kindVisitor = visitor[kind];\n  if (typeof kindVisitor === 'object') {\n    // { Kind: { enter() {}, leave() {} } }\n    return kindVisitor;\n  } else if (typeof kindVisitor === 'function') {\n    // { Kind() {} }\n    return {\n      enter: kindVisitor,\n      leave: undefined\n    };\n  } // { enter() {}, leave() {} }\n\n  return {\n    enter: visitor.enter,\n    leave: visitor.leave\n  };\n}\n/**\r\n * Given a visitor instance, if it is leaving or not, and a node kind, return\r\n * the function the visitor runtime should call.\r\n *\r\n * @deprecated Please use `getEnterLeaveForKind` instead. Will be removed in v17\r\n */\n\n/* c8 ignore next 8 */\n\nexport function getVisitFn(visitor, kind, isLeaving) {\n  const {\n    enter,\n    leave\n  } = getEnterLeaveForKind(visitor, kind);\n  return isLeaving ? leave : enter;\n}","map":{"version":3,"names":["devAssert","inspect","isNode","QueryDocumentKeys","Kind","BREAK","Object","freeze","visit","root","visitor","visitorKeys","arguments","length","undefined","enterLeaveMap","Map","kind","values","set","getEnterLeaveForKind","stack","inArray","Array","isArray","keys","index","edits","node","key","parent","path","ancestors","isLeaving","isEdited","pop","slice","editOffset","editKey","editValue","arrayKey","splice","defineProperties","getOwnPropertyDescriptors","prev","push","result","_enterLeaveMap$get","_enterLeaveMap$get2","visitFn","get","leave","enter","call","_node$kind","visitInParallel","visitors","skipping","fill","mergedVisitor","create","hasVisitor","enterList","leaveList","i","mergedEnterLeave","_len","args","_key","_enterList$i","apply","_len2","_key2","_leaveList$i","kindVisitor","getVisitFn"],"sources":["C:/Users/jared/PortfolioProjects/BookwormSE/Develop/client/node_modules/graphql/language/visitor.mjs"],"sourcesContent":["import { devAssert } from '../jsutils/devAssert.mjs';\r\nimport { inspect } from '../jsutils/inspect.mjs';\r\nimport { isNode, QueryDocumentKeys } from './ast.mjs';\r\nimport { Kind } from './kinds.mjs';\r\n/**\r\n * A visitor is provided to visit, it contains the collection of\r\n * relevant functions to be called during the visitor's traversal.\r\n */\r\n\r\nexport const BREAK = Object.freeze({});\r\n/**\r\n * visit() will walk through an AST using a depth-first traversal, calling\r\n * the visitor's enter function at each node in the traversal, and calling the\r\n * leave function after visiting that node and all of its child nodes.\r\n *\r\n * By returning different values from the enter and leave functions, the\r\n * behavior of the visitor can be altered, including skipping over a sub-tree of\r\n * the AST (by returning false), editing the AST by returning a value or null\r\n * to remove the value, or to stop the whole traversal by returning BREAK.\r\n *\r\n * When using visit() to edit an AST, the original AST will not be modified, and\r\n * a new version of the AST with the changes applied will be returned from the\r\n * visit function.\r\n *\r\n * ```ts\r\n * const editedAST = visit(ast, {\r\n *   enter(node, key, parent, path, ancestors) {\r\n *     // @return\r\n *     //   undefined: no action\r\n *     //   false: skip visiting this node\r\n *     //   visitor.BREAK: stop visiting altogether\r\n *     //   null: delete this node\r\n *     //   any value: replace this node with the returned value\r\n *   },\r\n *   leave(node, key, parent, path, ancestors) {\r\n *     // @return\r\n *     //   undefined: no action\r\n *     //   false: no action\r\n *     //   visitor.BREAK: stop visiting altogether\r\n *     //   null: delete this node\r\n *     //   any value: replace this node with the returned value\r\n *   }\r\n * });\r\n * ```\r\n *\r\n * Alternatively to providing enter() and leave() functions, a visitor can\r\n * instead provide functions named the same as the kinds of AST nodes, or\r\n * enter/leave visitors at a named key, leading to three permutations of the\r\n * visitor API:\r\n *\r\n * 1) Named visitors triggered when entering a node of a specific kind.\r\n *\r\n * ```ts\r\n * visit(ast, {\r\n *   Kind(node) {\r\n *     // enter the \"Kind\" node\r\n *   }\r\n * })\r\n * ```\r\n *\r\n * 2) Named visitors that trigger upon entering and leaving a node of a specific kind.\r\n *\r\n * ```ts\r\n * visit(ast, {\r\n *   Kind: {\r\n *     enter(node) {\r\n *       // enter the \"Kind\" node\r\n *     }\r\n *     leave(node) {\r\n *       // leave the \"Kind\" node\r\n *     }\r\n *   }\r\n * })\r\n * ```\r\n *\r\n * 3) Generic visitors that trigger upon entering and leaving any node.\r\n *\r\n * ```ts\r\n * visit(ast, {\r\n *   enter(node) {\r\n *     // enter any node\r\n *   },\r\n *   leave(node) {\r\n *     // leave any node\r\n *   }\r\n * })\r\n * ```\r\n */\r\n\r\nexport function visit(root, visitor, visitorKeys = QueryDocumentKeys) {\r\n  const enterLeaveMap = new Map();\r\n\r\n  for (const kind of Object.values(Kind)) {\r\n    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));\r\n  }\r\n  /* eslint-disable no-undef-init */\r\n\r\n  let stack = undefined;\r\n  let inArray = Array.isArray(root);\r\n  let keys = [root];\r\n  let index = -1;\r\n  let edits = [];\r\n  let node = root;\r\n  let key = undefined;\r\n  let parent = undefined;\r\n  const path = [];\r\n  const ancestors = [];\r\n  /* eslint-enable no-undef-init */\r\n\r\n  do {\r\n    index++;\r\n    const isLeaving = index === keys.length;\r\n    const isEdited = isLeaving && edits.length !== 0;\r\n\r\n    if (isLeaving) {\r\n      key = ancestors.length === 0 ? undefined : path[path.length - 1];\r\n      node = parent;\r\n      parent = ancestors.pop();\r\n\r\n      if (isEdited) {\r\n        if (inArray) {\r\n          node = node.slice();\r\n          let editOffset = 0;\r\n\r\n          for (const [editKey, editValue] of edits) {\r\n            const arrayKey = editKey - editOffset;\r\n\r\n            if (editValue === null) {\r\n              node.splice(arrayKey, 1);\r\n              editOffset++;\r\n            } else {\r\n              node[arrayKey] = editValue;\r\n            }\r\n          }\r\n        } else {\r\n          node = Object.defineProperties(\r\n            {},\r\n            Object.getOwnPropertyDescriptors(node),\r\n          );\r\n\r\n          for (const [editKey, editValue] of edits) {\r\n            node[editKey] = editValue;\r\n          }\r\n        }\r\n      }\r\n\r\n      index = stack.index;\r\n      keys = stack.keys;\r\n      edits = stack.edits;\r\n      inArray = stack.inArray;\r\n      stack = stack.prev;\r\n    } else if (parent) {\r\n      key = inArray ? index : keys[index];\r\n      node = parent[key];\r\n\r\n      if (node === null || node === undefined) {\r\n        continue;\r\n      }\r\n\r\n      path.push(key);\r\n    }\r\n\r\n    let result;\r\n\r\n    if (!Array.isArray(node)) {\r\n      var _enterLeaveMap$get, _enterLeaveMap$get2;\r\n\r\n      isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);\r\n      const visitFn = isLeaving\r\n        ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null ||\r\n          _enterLeaveMap$get === void 0\r\n          ? void 0\r\n          : _enterLeaveMap$get.leave\r\n        : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null ||\r\n          _enterLeaveMap$get2 === void 0\r\n        ? void 0\r\n        : _enterLeaveMap$get2.enter;\r\n      result =\r\n        visitFn === null || visitFn === void 0\r\n          ? void 0\r\n          : visitFn.call(visitor, node, key, parent, path, ancestors);\r\n\r\n      if (result === BREAK) {\r\n        break;\r\n      }\r\n\r\n      if (result === false) {\r\n        if (!isLeaving) {\r\n          path.pop();\r\n          continue;\r\n        }\r\n      } else if (result !== undefined) {\r\n        edits.push([key, result]);\r\n\r\n        if (!isLeaving) {\r\n          if (isNode(result)) {\r\n            node = result;\r\n          } else {\r\n            path.pop();\r\n            continue;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (result === undefined && isEdited) {\r\n      edits.push([key, node]);\r\n    }\r\n\r\n    if (isLeaving) {\r\n      path.pop();\r\n    } else {\r\n      var _node$kind;\r\n\r\n      stack = {\r\n        inArray,\r\n        index,\r\n        keys,\r\n        edits,\r\n        prev: stack,\r\n      };\r\n      inArray = Array.isArray(node);\r\n      keys = inArray\r\n        ? node\r\n        : (_node$kind = visitorKeys[node.kind]) !== null &&\r\n          _node$kind !== void 0\r\n        ? _node$kind\r\n        : [];\r\n      index = -1;\r\n      edits = [];\r\n\r\n      if (parent) {\r\n        ancestors.push(parent);\r\n      }\r\n\r\n      parent = node;\r\n    }\r\n  } while (stack !== undefined);\r\n\r\n  if (edits.length !== 0) {\r\n    // New root\r\n    return edits[edits.length - 1][1];\r\n  }\r\n\r\n  return root;\r\n}\r\n/**\r\n * Creates a new visitor instance which delegates to many visitors to run in\r\n * parallel. Each visitor will be visited for each node before moving on.\r\n *\r\n * If a prior visitor edits a node, no following visitors will see that node.\r\n */\r\n\r\nexport function visitInParallel(visitors) {\r\n  const skipping = new Array(visitors.length).fill(null);\r\n  const mergedVisitor = Object.create(null);\r\n\r\n  for (const kind of Object.values(Kind)) {\r\n    let hasVisitor = false;\r\n    const enterList = new Array(visitors.length).fill(undefined);\r\n    const leaveList = new Array(visitors.length).fill(undefined);\r\n\r\n    for (let i = 0; i < visitors.length; ++i) {\r\n      const { enter, leave } = getEnterLeaveForKind(visitors[i], kind);\r\n      hasVisitor || (hasVisitor = enter != null || leave != null);\r\n      enterList[i] = enter;\r\n      leaveList[i] = leave;\r\n    }\r\n\r\n    if (!hasVisitor) {\r\n      continue;\r\n    }\r\n\r\n    const mergedEnterLeave = {\r\n      enter(...args) {\r\n        const node = args[0];\r\n\r\n        for (let i = 0; i < visitors.length; i++) {\r\n          if (skipping[i] === null) {\r\n            var _enterList$i;\r\n\r\n            const result =\r\n              (_enterList$i = enterList[i]) === null || _enterList$i === void 0\r\n                ? void 0\r\n                : _enterList$i.apply(visitors[i], args);\r\n\r\n            if (result === false) {\r\n              skipping[i] = node;\r\n            } else if (result === BREAK) {\r\n              skipping[i] = BREAK;\r\n            } else if (result !== undefined) {\r\n              return result;\r\n            }\r\n          }\r\n        }\r\n      },\r\n\r\n      leave(...args) {\r\n        const node = args[0];\r\n\r\n        for (let i = 0; i < visitors.length; i++) {\r\n          if (skipping[i] === null) {\r\n            var _leaveList$i;\r\n\r\n            const result =\r\n              (_leaveList$i = leaveList[i]) === null || _leaveList$i === void 0\r\n                ? void 0\r\n                : _leaveList$i.apply(visitors[i], args);\r\n\r\n            if (result === BREAK) {\r\n              skipping[i] = BREAK;\r\n            } else if (result !== undefined && result !== false) {\r\n              return result;\r\n            }\r\n          } else if (skipping[i] === node) {\r\n            skipping[i] = null;\r\n          }\r\n        }\r\n      },\r\n    };\r\n    mergedVisitor[kind] = mergedEnterLeave;\r\n  }\r\n\r\n  return mergedVisitor;\r\n}\r\n/**\r\n * Given a visitor instance and a node kind, return EnterLeaveVisitor for that kind.\r\n */\r\n\r\nexport function getEnterLeaveForKind(visitor, kind) {\r\n  const kindVisitor = visitor[kind];\r\n\r\n  if (typeof kindVisitor === 'object') {\r\n    // { Kind: { enter() {}, leave() {} } }\r\n    return kindVisitor;\r\n  } else if (typeof kindVisitor === 'function') {\r\n    // { Kind() {} }\r\n    return {\r\n      enter: kindVisitor,\r\n      leave: undefined,\r\n    };\r\n  } // { enter() {}, leave() {} }\r\n\r\n  return {\r\n    enter: visitor.enter,\r\n    leave: visitor.leave,\r\n  };\r\n}\r\n/**\r\n * Given a visitor instance, if it is leaving or not, and a node kind, return\r\n * the function the visitor runtime should call.\r\n *\r\n * @deprecated Please use `getEnterLeaveForKind` instead. Will be removed in v17\r\n */\r\n\r\n/* c8 ignore next 8 */\r\n\r\nexport function getVisitFn(visitor, kind, isLeaving) {\r\n  const { enter, leave } = getEnterLeaveForKind(visitor, kind);\r\n  return isLeaving ? leave : enter;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}