{"ast":null,"code":"import _classCallCheck from \"C:/Users/jared/PortfolioProjects/BookwormSE/Develop/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/jared/PortfolioProjects/BookwormSE/Develop/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _createForOfIteratorHelper from \"C:/Users/jared/PortfolioProjects/BookwormSE/Develop/client/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { naturalCompare } from './naturalCompare.mjs';\n/**\r\n * Given an invalid input string and a list of valid options, returns a filtered\r\n * list of valid options sorted based on their similarity with the input.\r\n */\n\nexport function suggestionList(input, options) {\n  var optionsByDistance = Object.create(null);\n  var lexicalDistance = new LexicalDistance(input);\n  var threshold = Math.floor(input.length * 0.4) + 1;\n  var _iterator = _createForOfIteratorHelper(options),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var option = _step.value;\n      var distance = lexicalDistance.measure(option, threshold);\n      if (distance !== undefined) {\n        optionsByDistance[option] = distance;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return Object.keys(optionsByDistance).sort(function (a, b) {\n    var distanceDiff = optionsByDistance[a] - optionsByDistance[b];\n    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a, b);\n  });\n}\n/**\r\n * Computes the lexical distance between strings A and B.\r\n *\r\n * The \"distance\" between two strings is given by counting the minimum number\r\n * of edits needed to transform string A into string B. An edit can be an\r\n * insertion, deletion, or substitution of a single character, or a swap of two\r\n * adjacent characters.\r\n *\r\n * Includes a custom alteration from Damerau-Levenshtein to treat case changes\r\n * as a single edit which helps identify mis-cased values with an edit distance\r\n * of 1.\r\n *\r\n * This distance can be useful for detecting typos in input or sorting\r\n */\nvar LexicalDistance = /*#__PURE__*/function () {\n  function LexicalDistance(input) {\n    _classCallCheck(this, LexicalDistance);\n    this._input = input;\n    this._inputLowerCase = input.toLowerCase();\n    this._inputArray = stringToArray(this._inputLowerCase);\n    this._rows = [new Array(input.length + 1).fill(0), new Array(input.length + 1).fill(0), new Array(input.length + 1).fill(0)];\n  }\n  _createClass(LexicalDistance, [{\n    key: \"measure\",\n    value: function measure(option, threshold) {\n      if (this._input === option) {\n        return 0;\n      }\n      var optionLowerCase = option.toLowerCase(); // Any case change counts as a single edit\n\n      if (this._inputLowerCase === optionLowerCase) {\n        return 1;\n      }\n      var a = stringToArray(optionLowerCase);\n      var b = this._inputArray;\n      if (a.length < b.length) {\n        var tmp = a;\n        a = b;\n        b = tmp;\n      }\n      var aLength = a.length;\n      var bLength = b.length;\n      if (aLength - bLength > threshold) {\n        return undefined;\n      }\n      var rows = this._rows;\n      for (var j = 0; j <= bLength; j++) {\n        rows[0][j] = j;\n      }\n      for (var i = 1; i <= aLength; i++) {\n        var upRow = rows[(i - 1) % 3];\n        var currentRow = rows[i % 3];\n        var smallestCell = currentRow[0] = i;\n        for (var _j = 1; _j <= bLength; _j++) {\n          var cost = a[i - 1] === b[_j - 1] ? 0 : 1;\n          var currentCell = Math.min(upRow[_j] + 1,\n          // delete\n          currentRow[_j - 1] + 1,\n          // insert\n          upRow[_j - 1] + cost // substitute\n          );\n\n          if (i > 1 && _j > 1 && a[i - 1] === b[_j - 2] && a[i - 2] === b[_j - 1]) {\n            // transposition\n            var doubleDiagonalCell = rows[(i - 2) % 3][_j - 2];\n            currentCell = Math.min(currentCell, doubleDiagonalCell + 1);\n          }\n          if (currentCell < smallestCell) {\n            smallestCell = currentCell;\n          }\n          currentRow[_j] = currentCell;\n        } // Early exit, since distance can't go smaller than smallest element of the previous row.\n\n        if (smallestCell > threshold) {\n          return undefined;\n        }\n      }\n      var distance = rows[aLength % 3][bLength];\n      return distance <= threshold ? distance : undefined;\n    }\n  }]);\n  return LexicalDistance;\n}();\nfunction stringToArray(str) {\n  var strLength = str.length;\n  var array = new Array(strLength);\n  for (var i = 0; i < strLength; ++i) {\n    array[i] = str.charCodeAt(i);\n  }\n  return array;\n}","map":{"version":3,"names":["naturalCompare","suggestionList","input","options","optionsByDistance","Object","create","lexicalDistance","LexicalDistance","threshold","Math","floor","length","_iterator","_createForOfIteratorHelper","_step","s","n","done","option","value","distance","measure","undefined","err","e","f","keys","sort","a","b","distanceDiff","_classCallCheck","_input","_inputLowerCase","toLowerCase","_inputArray","stringToArray","_rows","Array","fill","_createClass","key","optionLowerCase","tmp","aLength","bLength","rows","j","i","upRow","currentRow","smallestCell","cost","currentCell","min","doubleDiagonalCell","str","strLength","array","charCodeAt"],"sources":["C:/Users/jared/PortfolioProjects/BookwormSE/Develop/client/node_modules/graphql/jsutils/suggestionList.mjs"],"sourcesContent":["import { naturalCompare } from './naturalCompare.mjs';\r\n/**\r\n * Given an invalid input string and a list of valid options, returns a filtered\r\n * list of valid options sorted based on their similarity with the input.\r\n */\r\n\r\nexport function suggestionList(input, options) {\r\n  const optionsByDistance = Object.create(null);\r\n  const lexicalDistance = new LexicalDistance(input);\r\n  const threshold = Math.floor(input.length * 0.4) + 1;\r\n\r\n  for (const option of options) {\r\n    const distance = lexicalDistance.measure(option, threshold);\r\n\r\n    if (distance !== undefined) {\r\n      optionsByDistance[option] = distance;\r\n    }\r\n  }\r\n\r\n  return Object.keys(optionsByDistance).sort((a, b) => {\r\n    const distanceDiff = optionsByDistance[a] - optionsByDistance[b];\r\n    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a, b);\r\n  });\r\n}\r\n/**\r\n * Computes the lexical distance between strings A and B.\r\n *\r\n * The \"distance\" between two strings is given by counting the minimum number\r\n * of edits needed to transform string A into string B. An edit can be an\r\n * insertion, deletion, or substitution of a single character, or a swap of two\r\n * adjacent characters.\r\n *\r\n * Includes a custom alteration from Damerau-Levenshtein to treat case changes\r\n * as a single edit which helps identify mis-cased values with an edit distance\r\n * of 1.\r\n *\r\n * This distance can be useful for detecting typos in input or sorting\r\n */\r\n\r\nclass LexicalDistance {\r\n  constructor(input) {\r\n    this._input = input;\r\n    this._inputLowerCase = input.toLowerCase();\r\n    this._inputArray = stringToArray(this._inputLowerCase);\r\n    this._rows = [\r\n      new Array(input.length + 1).fill(0),\r\n      new Array(input.length + 1).fill(0),\r\n      new Array(input.length + 1).fill(0),\r\n    ];\r\n  }\r\n\r\n  measure(option, threshold) {\r\n    if (this._input === option) {\r\n      return 0;\r\n    }\r\n\r\n    const optionLowerCase = option.toLowerCase(); // Any case change counts as a single edit\r\n\r\n    if (this._inputLowerCase === optionLowerCase) {\r\n      return 1;\r\n    }\r\n\r\n    let a = stringToArray(optionLowerCase);\r\n    let b = this._inputArray;\r\n\r\n    if (a.length < b.length) {\r\n      const tmp = a;\r\n      a = b;\r\n      b = tmp;\r\n    }\r\n\r\n    const aLength = a.length;\r\n    const bLength = b.length;\r\n\r\n    if (aLength - bLength > threshold) {\r\n      return undefined;\r\n    }\r\n\r\n    const rows = this._rows;\r\n\r\n    for (let j = 0; j <= bLength; j++) {\r\n      rows[0][j] = j;\r\n    }\r\n\r\n    for (let i = 1; i <= aLength; i++) {\r\n      const upRow = rows[(i - 1) % 3];\r\n      const currentRow = rows[i % 3];\r\n      let smallestCell = (currentRow[0] = i);\r\n\r\n      for (let j = 1; j <= bLength; j++) {\r\n        const cost = a[i - 1] === b[j - 1] ? 0 : 1;\r\n        let currentCell = Math.min(\r\n          upRow[j] + 1, // delete\r\n          currentRow[j - 1] + 1, // insert\r\n          upRow[j - 1] + cost, // substitute\r\n        );\r\n\r\n        if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\r\n          // transposition\r\n          const doubleDiagonalCell = rows[(i - 2) % 3][j - 2];\r\n          currentCell = Math.min(currentCell, doubleDiagonalCell + 1);\r\n        }\r\n\r\n        if (currentCell < smallestCell) {\r\n          smallestCell = currentCell;\r\n        }\r\n\r\n        currentRow[j] = currentCell;\r\n      } // Early exit, since distance can't go smaller than smallest element of the previous row.\r\n\r\n      if (smallestCell > threshold) {\r\n        return undefined;\r\n      }\r\n    }\r\n\r\n    const distance = rows[aLength % 3][bLength];\r\n    return distance <= threshold ? distance : undefined;\r\n  }\r\n}\r\n\r\nfunction stringToArray(str) {\r\n  const strLength = str.length;\r\n  const array = new Array(strLength);\r\n\r\n  for (let i = 0; i < strLength; ++i) {\r\n    array[i] = str.charCodeAt(i);\r\n  }\r\n\r\n  return array;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}