{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/jared/PortfolioProjects/BookwormSE/Develop/client/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\r\n * No fragment cycles\r\n *\r\n * The graph of fragment spreads must not form any cycles including spreading itself.\r\n * Otherwise an operation could infinitely spread or infinitely execute on cycles in the underlying data.\r\n *\r\n * See https://spec.graphql.org/draft/#sec-Fragment-spreads-must-not-form-cycles\r\n */\nexport function NoFragmentCyclesRule(context) {\n  // Tracks already visited fragments to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  var visitedFrags = Object.create(null); // Array of AST nodes used to produce meaningful errors\n\n  var spreadPath = []; // Position in the spread path\n\n  var spreadPathIndexByName = Object.create(null);\n  return {\n    OperationDefinition: function OperationDefinition() {\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      detectCycleRecursive(node);\n      return false;\n    }\n  }; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(fragment) {\n    if (visitedFrags[fragment.name.value]) {\n      return;\n    }\n    var fragmentName = fragment.name.value;\n    visitedFrags[fragmentName] = true;\n    var spreadNodes = context.getFragmentSpreads(fragment.selectionSet);\n    if (spreadNodes.length === 0) {\n      return;\n    }\n    spreadPathIndexByName[fragmentName] = spreadPath.length;\n    var _iterator = _createForOfIteratorHelper(spreadNodes),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var spreadNode = _step.value;\n        var spreadName = spreadNode.name.value;\n        var cycleIndex = spreadPathIndexByName[spreadName];\n        spreadPath.push(spreadNode);\n        if (cycleIndex === undefined) {\n          var spreadFragment = context.getFragment(spreadName);\n          if (spreadFragment) {\n            detectCycleRecursive(spreadFragment);\n          }\n        } else {\n          var cyclePath = spreadPath.slice(cycleIndex);\n          var viaPath = cyclePath.slice(0, -1).map(function (s) {\n            return '\"' + s.name.value + '\"';\n          }).join(', ');\n          context.reportError(new GraphQLError(\"Cannot spread fragment \\\"\".concat(spreadName, \"\\\" within itself\") + (viaPath !== '' ? \" via \".concat(viaPath, \".\") : '.'), {\n            nodes: cyclePath\n          }));\n        }\n        spreadPath.pop();\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    spreadPathIndexByName[fragmentName] = undefined;\n  }\n}","map":{"version":3,"names":["GraphQLError","NoFragmentCyclesRule","context","visitedFrags","Object","create","spreadPath","spreadPathIndexByName","OperationDefinition","FragmentDefinition","node","detectCycleRecursive","fragment","name","value","fragmentName","spreadNodes","getFragmentSpreads","selectionSet","length","_iterator","_createForOfIteratorHelper","_step","s","n","done","spreadNode","spreadName","cycleIndex","push","undefined","spreadFragment","getFragment","cyclePath","slice","viaPath","map","join","reportError","concat","nodes","pop","err","e","f"],"sources":["C:/Users/jared/PortfolioProjects/BookwormSE/Develop/client/node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.mjs';\r\n\r\n/**\r\n * No fragment cycles\r\n *\r\n * The graph of fragment spreads must not form any cycles including spreading itself.\r\n * Otherwise an operation could infinitely spread or infinitely execute on cycles in the underlying data.\r\n *\r\n * See https://spec.graphql.org/draft/#sec-Fragment-spreads-must-not-form-cycles\r\n */\r\nexport function NoFragmentCyclesRule(context) {\r\n  // Tracks already visited fragments to maintain O(N) and to ensure that cycles\r\n  // are not redundantly reported.\r\n  const visitedFrags = Object.create(null); // Array of AST nodes used to produce meaningful errors\r\n\r\n  const spreadPath = []; // Position in the spread path\r\n\r\n  const spreadPathIndexByName = Object.create(null);\r\n  return {\r\n    OperationDefinition: () => false,\r\n\r\n    FragmentDefinition(node) {\r\n      detectCycleRecursive(node);\r\n      return false;\r\n    },\r\n  }; // This does a straight-forward DFS to find cycles.\r\n  // It does not terminate when a cycle was found but continues to explore\r\n  // the graph to find all possible cycles.\r\n\r\n  function detectCycleRecursive(fragment) {\r\n    if (visitedFrags[fragment.name.value]) {\r\n      return;\r\n    }\r\n\r\n    const fragmentName = fragment.name.value;\r\n    visitedFrags[fragmentName] = true;\r\n    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);\r\n\r\n    if (spreadNodes.length === 0) {\r\n      return;\r\n    }\r\n\r\n    spreadPathIndexByName[fragmentName] = spreadPath.length;\r\n\r\n    for (const spreadNode of spreadNodes) {\r\n      const spreadName = spreadNode.name.value;\r\n      const cycleIndex = spreadPathIndexByName[spreadName];\r\n      spreadPath.push(spreadNode);\r\n\r\n      if (cycleIndex === undefined) {\r\n        const spreadFragment = context.getFragment(spreadName);\r\n\r\n        if (spreadFragment) {\r\n          detectCycleRecursive(spreadFragment);\r\n        }\r\n      } else {\r\n        const cyclePath = spreadPath.slice(cycleIndex);\r\n        const viaPath = cyclePath\r\n          .slice(0, -1)\r\n          .map((s) => '\"' + s.name.value + '\"')\r\n          .join(', ');\r\n        context.reportError(\r\n          new GraphQLError(\r\n            `Cannot spread fragment \"${spreadName}\" within itself` +\r\n              (viaPath !== '' ? ` via ${viaPath}.` : '.'),\r\n            {\r\n              nodes: cyclePath,\r\n            },\r\n          ),\r\n        );\r\n      }\r\n\r\n      spreadPath.pop();\r\n    }\r\n\r\n    spreadPathIndexByName[fragmentName] = undefined;\r\n  }\r\n}\r\n"],"mappings":";AAAA,SAASA,YAAY,QAAQ,8BAA8B;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,oBAAoBA,CAACC,OAAO,EAAE;EAC5C;EACA;EACA,IAAMC,YAAY,GAAGC,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;;EAE1C,IAAMC,UAAU,GAAG,EAAE,CAAC,CAAC;;EAEvB,IAAMC,qBAAqB,GAAGH,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;EACjD,OAAO;IACLG,mBAAmB,EAAE,SAAAA,oBAAA;MAAA,OAAM,KAAK;IAAA;IAEhCC,kBAAkB,WAAAA,mBAACC,IAAI,EAAE;MACvBC,oBAAoB,CAACD,IAAI,CAAC;MAC1B,OAAO,KAAK;IACd;EACF,CAAC,CAAC,CAAC;EACH;EACA;;EAEA,SAASC,oBAAoBA,CAACC,QAAQ,EAAE;IACtC,IAAIT,YAAY,CAACS,QAAQ,CAACC,IAAI,CAACC,KAAK,CAAC,EAAE;MACrC;IACF;IAEA,IAAMC,YAAY,GAAGH,QAAQ,CAACC,IAAI,CAACC,KAAK;IACxCX,YAAY,CAACY,YAAY,CAAC,GAAG,IAAI;IACjC,IAAMC,WAAW,GAAGd,OAAO,CAACe,kBAAkB,CAACL,QAAQ,CAACM,YAAY,CAAC;IAErE,IAAIF,WAAW,CAACG,MAAM,KAAK,CAAC,EAAE;MAC5B;IACF;IAEAZ,qBAAqB,CAACQ,YAAY,CAAC,GAAGT,UAAU,CAACa,MAAM;IAAC,IAAAC,SAAA,GAAAC,0BAAA,CAE/BL,WAAW;MAAAM,KAAA;IAAA;MAApC,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAAsC;QAAA,IAA3BC,UAAU,GAAAJ,KAAA,CAAAR,KAAA;QACnB,IAAMa,UAAU,GAAGD,UAAU,CAACb,IAAI,CAACC,KAAK;QACxC,IAAMc,UAAU,GAAGrB,qBAAqB,CAACoB,UAAU,CAAC;QACpDrB,UAAU,CAACuB,IAAI,CAACH,UAAU,CAAC;QAE3B,IAAIE,UAAU,KAAKE,SAAS,EAAE;UAC5B,IAAMC,cAAc,GAAG7B,OAAO,CAAC8B,WAAW,CAACL,UAAU,CAAC;UAEtD,IAAII,cAAc,EAAE;YAClBpB,oBAAoB,CAACoB,cAAc,CAAC;UACtC;QACF,CAAC,MAAM;UACL,IAAME,SAAS,GAAG3B,UAAU,CAAC4B,KAAK,CAACN,UAAU,CAAC;UAC9C,IAAMO,OAAO,GAAGF,SAAS,CACtBC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CACZE,GAAG,CAAC,UAACb,CAAC;YAAA,OAAK,GAAG,GAAGA,CAAC,CAACV,IAAI,CAACC,KAAK,GAAG,GAAG;UAAA,EAAC,CACpCuB,IAAI,CAAC,IAAI,CAAC;UACbnC,OAAO,CAACoC,WAAW,CACjB,IAAItC,YAAY,CACd,4BAAAuC,MAAA,CAA2BZ,UAAU,yBAClCQ,OAAO,KAAK,EAAE,WAAAI,MAAA,CAAWJ,OAAO,SAAM,GAAG,CAAC,EAC7C;YACEK,KAAK,EAAEP;UACT,CACF,CACF,CAAC;QACH;QAEA3B,UAAU,CAACmC,GAAG,CAAC,CAAC;MAClB;IAAC,SAAAC,GAAA;MAAAtB,SAAA,CAAAuB,CAAA,CAAAD,GAAA;IAAA;MAAAtB,SAAA,CAAAwB,CAAA;IAAA;IAEDrC,qBAAqB,CAACQ,YAAY,CAAC,GAAGe,SAAS;EACjD;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}