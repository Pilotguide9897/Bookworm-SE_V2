{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/jared/PortfolioProjects/BookwormSE/Develop/client/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { Kind } from '../language/kinds.mjs';\nimport { isAbstractType } from '../type/definition.mjs';\nimport { GraphQLIncludeDirective, GraphQLSkipDirective } from '../type/directives.mjs';\nimport { typeFromAST } from '../utilities/typeFromAST.mjs';\nimport { getDirectiveValues } from './values.mjs';\n/**\r\n * Given a selectionSet, collects all of the fields and returns them.\r\n *\r\n * CollectFields requires the \"runtime type\" of an object. For a field that\r\n * returns an Interface or Union type, the \"runtime type\" will be the actual\r\n * object type returned by that field.\r\n *\r\n * @internal\r\n */\n\nexport function collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {\n  var fields = new Map();\n  collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, new Set());\n  return fields;\n}\n/**\r\n * Given an array of field nodes, collects all of the subfields of the passed\r\n * in fields, and returns them at the end.\r\n *\r\n * CollectSubFields requires the \"return type\" of an object. For a field that\r\n * returns an Interface or Union type, the \"return type\" will be the actual\r\n * object type returned by that field.\r\n *\r\n * @internal\r\n */\n\nexport function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {\n  var subFieldNodes = new Map();\n  var visitedFragmentNames = new Set();\n  var _iterator = _createForOfIteratorHelper(fieldNodes),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var node = _step.value;\n      if (node.selectionSet) {\n        collectFieldsImpl(schema, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, visitedFragmentNames);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return subFieldNodes;\n}\nfunction collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {\n  var _iterator2 = _createForOfIteratorHelper(selectionSet.selections),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var selection = _step2.value;\n      switch (selection.kind) {\n        case Kind.FIELD:\n          {\n            if (!shouldIncludeNode(variableValues, selection)) {\n              continue;\n            }\n            var name = getFieldEntryKey(selection);\n            var fieldList = fields.get(name);\n            if (fieldList !== undefined) {\n              fieldList.push(selection);\n            } else {\n              fields.set(name, [selection]);\n            }\n            break;\n          }\n        case Kind.INLINE_FRAGMENT:\n          {\n            if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {\n              continue;\n            }\n            collectFieldsImpl(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);\n            break;\n          }\n        case Kind.FRAGMENT_SPREAD:\n          {\n            var fragName = selection.name.value;\n            if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {\n              continue;\n            }\n            visitedFragmentNames.add(fragName);\n            var fragment = fragments[fragName];\n            if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {\n              continue;\n            }\n            collectFieldsImpl(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);\n            break;\n          }\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n}\n/**\r\n * Determines if a field should be included based on the `@include` and `@skip`\r\n * directives, where `@skip` has higher precedence than `@include`.\r\n */\n\nfunction shouldIncludeNode(variableValues, node) {\n  var skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);\n  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {\n    return false;\n  }\n  var include = getDirectiveValues(GraphQLIncludeDirective, node, variableValues);\n  if ((include === null || include === void 0 ? void 0 : include.if) === false) {\n    return false;\n  }\n  return true;\n}\n/**\r\n * Determines if a fragment is applicable to the given type.\r\n */\n\nfunction doesFragmentConditionMatch(schema, fragment, type) {\n  var typeConditionNode = fragment.typeCondition;\n  if (!typeConditionNode) {\n    return true;\n  }\n  var conditionalType = typeFromAST(schema, typeConditionNode);\n  if (conditionalType === type) {\n    return true;\n  }\n  if (isAbstractType(conditionalType)) {\n    return schema.isSubType(conditionalType, type);\n  }\n  return false;\n}\n/**\r\n * Implements the logic to compute the key of a given field's entry\r\n */\n\nfunction getFieldEntryKey(node) {\n  return node.alias ? node.alias.value : node.name.value;\n}","map":{"version":3,"names":["Kind","isAbstractType","GraphQLIncludeDirective","GraphQLSkipDirective","typeFromAST","getDirectiveValues","collectFields","schema","fragments","variableValues","runtimeType","selectionSet","fields","Map","collectFieldsImpl","Set","collectSubfields","returnType","fieldNodes","subFieldNodes","visitedFragmentNames","_iterator","_createForOfIteratorHelper","_step","s","n","done","node","value","err","e","f","_iterator2","selections","_step2","selection","kind","FIELD","shouldIncludeNode","name","getFieldEntryKey","fieldList","get","undefined","push","set","INLINE_FRAGMENT","doesFragmentConditionMatch","FRAGMENT_SPREAD","fragName","has","add","fragment","skip","if","include","type","typeConditionNode","typeCondition","conditionalType","isSubType","alias"],"sources":["C:/Users/jared/PortfolioProjects/BookwormSE/Develop/client/node_modules/graphql/execution/collectFields.mjs"],"sourcesContent":["import { Kind } from '../language/kinds.mjs';\r\nimport { isAbstractType } from '../type/definition.mjs';\r\nimport {\r\n  GraphQLIncludeDirective,\r\n  GraphQLSkipDirective,\r\n} from '../type/directives.mjs';\r\nimport { typeFromAST } from '../utilities/typeFromAST.mjs';\r\nimport { getDirectiveValues } from './values.mjs';\r\n/**\r\n * Given a selectionSet, collects all of the fields and returns them.\r\n *\r\n * CollectFields requires the \"runtime type\" of an object. For a field that\r\n * returns an Interface or Union type, the \"runtime type\" will be the actual\r\n * object type returned by that field.\r\n *\r\n * @internal\r\n */\r\n\r\nexport function collectFields(\r\n  schema,\r\n  fragments,\r\n  variableValues,\r\n  runtimeType,\r\n  selectionSet,\r\n) {\r\n  const fields = new Map();\r\n  collectFieldsImpl(\r\n    schema,\r\n    fragments,\r\n    variableValues,\r\n    runtimeType,\r\n    selectionSet,\r\n    fields,\r\n    new Set(),\r\n  );\r\n  return fields;\r\n}\r\n/**\r\n * Given an array of field nodes, collects all of the subfields of the passed\r\n * in fields, and returns them at the end.\r\n *\r\n * CollectSubFields requires the \"return type\" of an object. For a field that\r\n * returns an Interface or Union type, the \"return type\" will be the actual\r\n * object type returned by that field.\r\n *\r\n * @internal\r\n */\r\n\r\nexport function collectSubfields(\r\n  schema,\r\n  fragments,\r\n  variableValues,\r\n  returnType,\r\n  fieldNodes,\r\n) {\r\n  const subFieldNodes = new Map();\r\n  const visitedFragmentNames = new Set();\r\n\r\n  for (const node of fieldNodes) {\r\n    if (node.selectionSet) {\r\n      collectFieldsImpl(\r\n        schema,\r\n        fragments,\r\n        variableValues,\r\n        returnType,\r\n        node.selectionSet,\r\n        subFieldNodes,\r\n        visitedFragmentNames,\r\n      );\r\n    }\r\n  }\r\n\r\n  return subFieldNodes;\r\n}\r\n\r\nfunction collectFieldsImpl(\r\n  schema,\r\n  fragments,\r\n  variableValues,\r\n  runtimeType,\r\n  selectionSet,\r\n  fields,\r\n  visitedFragmentNames,\r\n) {\r\n  for (const selection of selectionSet.selections) {\r\n    switch (selection.kind) {\r\n      case Kind.FIELD: {\r\n        if (!shouldIncludeNode(variableValues, selection)) {\r\n          continue;\r\n        }\r\n\r\n        const name = getFieldEntryKey(selection);\r\n        const fieldList = fields.get(name);\r\n\r\n        if (fieldList !== undefined) {\r\n          fieldList.push(selection);\r\n        } else {\r\n          fields.set(name, [selection]);\r\n        }\r\n\r\n        break;\r\n      }\r\n\r\n      case Kind.INLINE_FRAGMENT: {\r\n        if (\r\n          !shouldIncludeNode(variableValues, selection) ||\r\n          !doesFragmentConditionMatch(schema, selection, runtimeType)\r\n        ) {\r\n          continue;\r\n        }\r\n\r\n        collectFieldsImpl(\r\n          schema,\r\n          fragments,\r\n          variableValues,\r\n          runtimeType,\r\n          selection.selectionSet,\r\n          fields,\r\n          visitedFragmentNames,\r\n        );\r\n        break;\r\n      }\r\n\r\n      case Kind.FRAGMENT_SPREAD: {\r\n        const fragName = selection.name.value;\r\n\r\n        if (\r\n          visitedFragmentNames.has(fragName) ||\r\n          !shouldIncludeNode(variableValues, selection)\r\n        ) {\r\n          continue;\r\n        }\r\n\r\n        visitedFragmentNames.add(fragName);\r\n        const fragment = fragments[fragName];\r\n\r\n        if (\r\n          !fragment ||\r\n          !doesFragmentConditionMatch(schema, fragment, runtimeType)\r\n        ) {\r\n          continue;\r\n        }\r\n\r\n        collectFieldsImpl(\r\n          schema,\r\n          fragments,\r\n          variableValues,\r\n          runtimeType,\r\n          fragment.selectionSet,\r\n          fields,\r\n          visitedFragmentNames,\r\n        );\r\n        break;\r\n      }\r\n    }\r\n  }\r\n}\r\n/**\r\n * Determines if a field should be included based on the `@include` and `@skip`\r\n * directives, where `@skip` has higher precedence than `@include`.\r\n */\r\n\r\nfunction shouldIncludeNode(variableValues, node) {\r\n  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);\r\n\r\n  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {\r\n    return false;\r\n  }\r\n\r\n  const include = getDirectiveValues(\r\n    GraphQLIncludeDirective,\r\n    node,\r\n    variableValues,\r\n  );\r\n\r\n  if (\r\n    (include === null || include === void 0 ? void 0 : include.if) === false\r\n  ) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n/**\r\n * Determines if a fragment is applicable to the given type.\r\n */\r\n\r\nfunction doesFragmentConditionMatch(schema, fragment, type) {\r\n  const typeConditionNode = fragment.typeCondition;\r\n\r\n  if (!typeConditionNode) {\r\n    return true;\r\n  }\r\n\r\n  const conditionalType = typeFromAST(schema, typeConditionNode);\r\n\r\n  if (conditionalType === type) {\r\n    return true;\r\n  }\r\n\r\n  if (isAbstractType(conditionalType)) {\r\n    return schema.isSubType(conditionalType, type);\r\n  }\r\n\r\n  return false;\r\n}\r\n/**\r\n * Implements the logic to compute the key of a given field's entry\r\n */\r\n\r\nfunction getFieldEntryKey(node) {\r\n  return node.alias ? node.alias.value : node.name.value;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}