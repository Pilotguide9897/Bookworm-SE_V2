{"ast":null,"code":"import _classCallCheck from \"C:/Users/jared/PortfolioProjects/BookwormSE/Develop/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/jared/PortfolioProjects/BookwormSE/Develop/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _toConsumableArray from \"C:/Users/jared/PortfolioProjects/BookwormSE/Develop/client/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"C:/Users/jared/PortfolioProjects/BookwormSE/Develop/client/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"C:/Users/jared/PortfolioProjects/BookwormSE/Develop/client/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { print } from '../../language/printer.mjs';\nimport { getNamedType, isInterfaceType, isLeafType, isListType, isNonNullType, isObjectType } from '../../type/definition.mjs';\nimport { sortValueNode } from '../../utilities/sortValueNode.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason.map(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        responseName = _ref2[0],\n        subReason = _ref2[1];\n      return \"subfields \\\"\".concat(responseName, \"\\\" conflict because \") + reasonMessage(subReason);\n    }).join(' and ');\n  }\n  return reason;\n}\n/**\r\n * Overlapping fields can be merged\r\n *\r\n * A selection set is only valid if all fields (including spreading any\r\n * fragments) either correspond to distinct response names or can be merged\r\n * without ambiguity.\r\n *\r\n * See https://spec.graphql.org/draft/#sec-Field-Selection-Merging\r\n */\n\nexport function OverlappingFieldsCanBeMergedRule(context) {\n  // A memoization for when two fragments are compared \"between\" each other for\n  // conflicts. Two fragments may be compared many times, so memoizing this can\n  // dramatically improve the performance of this validator.\n  var comparedFragmentPairs = new PairSet(); // A cache for the \"field map\" and list of fragment names found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n\n  var cachedFieldsAndFragmentNames = new Map();\n  return {\n    SelectionSet: function SelectionSet(selectionSet) {\n      var conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);\n      var _iterator = _createForOfIteratorHelper(conflicts),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 3),\n            _step$value$ = _slicedToArray(_step$value[0], 2),\n            responseName = _step$value$[0],\n            reason = _step$value$[1],\n            fields1 = _step$value[1],\n            fields2 = _step$value[2];\n          var reasonMsg = reasonMessage(reason);\n          context.reportError(new GraphQLError(\"Fields \\\"\".concat(responseName, \"\\\" conflict because \").concat(reasonMsg, \". Use different aliases on the fields to fetch both if this was intentional.\"), {\n            nodes: fields1.concat(fields2)\n          }));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  };\n}\n\n/**\r\n * Algorithm:\r\n *\r\n * Conflicts occur when two fields exist in a query which will produce the same\r\n * response name, but represent differing values, thus creating a conflict.\r\n * The algorithm below finds all conflicts via making a series of comparisons\r\n * between fields. In order to compare as few fields as possible, this makes\r\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\r\n *\r\n * Given any selection set, a collection produces both a set of fields by\r\n * also including all inline fragments, as well as a list of fragments\r\n * referenced by fragment spreads.\r\n *\r\n * A) Each selection set represented in the document first compares \"within\" its\r\n * collected set of fields, finding any conflicts between every pair of\r\n * overlapping fields.\r\n * Note: This is the *only time* that a the fields \"within\" a set are compared\r\n * to each other. After this only fields \"between\" sets are compared.\r\n *\r\n * B) Also, if any fragment is referenced in a selection set, then a\r\n * comparison is made \"between\" the original set of fields and the\r\n * referenced fragment.\r\n *\r\n * C) Also, if multiple fragments are referenced, then comparisons\r\n * are made \"between\" each referenced fragment.\r\n *\r\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\r\n * a comparison is made between each field in the original set of fields and\r\n * each field in the the referenced set of fields.\r\n *\r\n * E) Also, if any fragment is referenced in the referenced selection set,\r\n * then a comparison is made \"between\" the original set of fields and the\r\n * referenced fragment (recursively referring to step D).\r\n *\r\n * F) When comparing \"between\" two fragments, first a comparison is made between\r\n * each field in the first referenced set of fields and each field in the the\r\n * second referenced set of fields.\r\n *\r\n * G) Also, any fragments referenced by the first must be compared to the\r\n * second, and any fragments referenced by the second must be compared to the\r\n * first (recursively referring to step F).\r\n *\r\n * H) When comparing two fields, if both have selection sets, then a comparison\r\n * is made \"between\" both selection sets, first comparing the set of fields in\r\n * the first selection set with the set of fields in the second.\r\n *\r\n * I) Also, if any fragment is referenced in either selection set, then a\r\n * comparison is made \"between\" the other set of fields and the\r\n * referenced fragment.\r\n *\r\n * J) Also, if two fragments are referenced in both selection sets, then a\r\n * comparison is made \"between\" the two fragments.\r\n *\r\n */\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\nfunction findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {\n  var conflicts = [];\n  var _getFieldsAndFragment = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet),\n    _getFieldsAndFragment2 = _slicedToArray(_getFieldsAndFragment, 2),\n    fieldMap = _getFieldsAndFragment2[0],\n    fragmentNames = _getFieldsAndFragment2[1]; // (A) Find find all conflicts \"within\" the fields of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n\n  collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);\n  if (fragmentNames.length !== 0) {\n    // (B) Then collect conflicts between these fields and those represented by\n    // each spread fragment name found.\n    for (var i = 0; i < fragmentNames.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fieldMap, fragmentNames[i]); // (C) Then compare this fragment with all other fragments found in this\n      // selection set to collect conflicts between fragments spread together.\n      // This compares each item in the list of fragment names to every other\n      // item in that same list (except for itself).\n\n      for (var j = i + 1; j < fragmentNames.length; j++) {\n        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);\n      }\n    }\n  }\n  return conflicts;\n} // Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\n\nfunction collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {\n  var fragment = context.getFragment(fragmentName);\n  if (!fragment) {\n    return;\n  }\n  var _getReferencedFieldsA = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment),\n    _getReferencedFieldsA2 = _slicedToArray(_getReferencedFieldsA, 2),\n    fieldMap2 = _getReferencedFieldsA2[0],\n    referencedFragmentNames = _getReferencedFieldsA2[1]; // Do not compare a fragment's fieldMap to itself.\n\n  if (fieldMap === fieldMap2) {\n    return;\n  } // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2); // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n  var _iterator2 = _createForOfIteratorHelper(referencedFragmentNames),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var referencedFragmentName = _step2.value;\n      // Memoize so two fragments are not compared for conflicts more than once.\n      if (comparedFragmentPairs.has(referencedFragmentName, fragmentName, areMutuallyExclusive)) {\n        continue;\n      }\n      comparedFragmentPairs.add(referencedFragmentName, fragmentName, areMutuallyExclusive);\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, referencedFragmentName);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n} // Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\n\nfunction collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {\n  // No need to compare a fragment to itself.\n  if (fragmentName1 === fragmentName2) {\n    return;\n  } // Memoize so two fragments are not compared for conflicts more than once.\n\n  if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {\n    return;\n  }\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n  var fragment1 = context.getFragment(fragmentName1);\n  var fragment2 = context.getFragment(fragmentName2);\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n  var _getReferencedFieldsA3 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1),\n    _getReferencedFieldsA4 = _slicedToArray(_getReferencedFieldsA3, 2),\n    fieldMap1 = _getReferencedFieldsA4[0],\n    referencedFragmentNames1 = _getReferencedFieldsA4[1];\n  var _getReferencedFieldsA5 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2),\n    _getReferencedFieldsA6 = _slicedToArray(_getReferencedFieldsA5, 2),\n    fieldMap2 = _getReferencedFieldsA6[0],\n    referencedFragmentNames2 = _getReferencedFieldsA6[1]; // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n  var _iterator3 = _createForOfIteratorHelper(referencedFragmentNames2),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var referencedFragmentName2 = _step3.value;\n      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, referencedFragmentName2);\n    } // (G) Then collect conflicts between the second fragment and any nested\n    // fragments spread in the first fragment.\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  var _iterator4 = _createForOfIteratorHelper(referencedFragmentNames1),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var referencedFragmentName1 = _step4.value;\n      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, referencedFragmentName1, fragmentName2);\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n} // Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\n\nfunction findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {\n  var conflicts = [];\n  var _getFieldsAndFragment3 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1),\n    _getFieldsAndFragment4 = _slicedToArray(_getFieldsAndFragment3, 2),\n    fieldMap1 = _getFieldsAndFragment4[0],\n    fragmentNames1 = _getFieldsAndFragment4[1];\n  var _getFieldsAndFragment5 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2),\n    _getFieldsAndFragment6 = _slicedToArray(_getFieldsAndFragment5, 2),\n    fieldMap2 = _getFieldsAndFragment6[0],\n    fragmentNames2 = _getFieldsAndFragment6[1]; // (H) First, collect all conflicts between these two collections of field.\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n  var _iterator5 = _createForOfIteratorHelper(fragmentNames2),\n    _step5;\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var fragmentName2 = _step5.value;\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentName2);\n    } // (I) Then collect conflicts between the second collection of fields and\n    // those referenced by each fragment name associated with the first.\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n  var _iterator6 = _createForOfIteratorHelper(fragmentNames1),\n    _step6;\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var fragmentName1 = _step6.value;\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentName1);\n    } // (J) Also collect conflicts between any fragment names by the first and\n    // fragment names by the second. This compares each item in the first set of\n    // names to each item in the second set of names.\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n  var _iterator7 = _createForOfIteratorHelper(fragmentNames1),\n    _step7;\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var _fragmentName = _step7.value;\n      var _iterator8 = _createForOfIteratorHelper(fragmentNames2),\n        _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var _fragmentName2 = _step8.value;\n          collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, _fragmentName, _fragmentName2);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n  return conflicts;\n} // Collect all Conflicts \"within\" one collection of fields.\n\nfunction collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  for (var _i = 0, _Object$entries = Object.entries(fieldMap); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n      responseName = _Object$entries$_i[0],\n      fields = _Object$entries$_i[1];\n    // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n    if (fields.length > 1) {\n      for (var i = 0; i < fields.length; i++) {\n        for (var j = i + 1; j < fields.length; j++) {\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false,\n          // within one collection is never mutually exclusive\n          responseName, fields[i], fields[j]);\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\n\nfunction collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  for (var _i2 = 0, _Object$entries2 = Object.entries(fieldMap1); _i2 < _Object$entries2.length; _i2++) {\n    var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),\n      responseName = _Object$entries2$_i[0],\n      fields1 = _Object$entries2$_i[1];\n    var fields2 = fieldMap2[responseName];\n    if (fields2) {\n      var _iterator9 = _createForOfIteratorHelper(fields1),\n        _step9;\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var field1 = _step9.value;\n          var _iterator10 = _createForOfIteratorHelper(fields2),\n            _step10;\n          try {\n            for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n              var field2 = _step10.value;\n              var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2);\n              if (conflict) {\n                conflicts.push(conflict);\n              }\n            }\n          } catch (err) {\n            _iterator10.e(err);\n          } finally {\n            _iterator10.f();\n          }\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n    }\n  }\n} // Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\n\nfunction findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {\n  var _field = _slicedToArray(field1, 3),\n    parentType1 = _field[0],\n    node1 = _field[1],\n    def1 = _field[2];\n  var _field2 = _slicedToArray(field2, 3),\n    parentType2 = _field2[0],\n    node2 = _field2[1],\n    def2 = _field2[2]; // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n\n  var areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);\n  if (!areMutuallyExclusive) {\n    // Two aliases must refer to the same field.\n    var name1 = node1.name.value;\n    var name2 = node2.name.value;\n    if (name1 !== name2) {\n      return [[responseName, \"\\\"\".concat(name1, \"\\\" and \\\"\").concat(name2, \"\\\" are different fields\")], [node1], [node2]];\n    } // Two field calls must have the same arguments.\n\n    if (stringifyArguments(node1) !== stringifyArguments(node2)) {\n      return [[responseName, 'they have differing arguments'], [node1], [node2]];\n    }\n  } // The return type for each field.\n\n  var type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;\n  var type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [[responseName, \"they return conflicting types \\\"\".concat(inspect(type1), \"\\\" and \\\"\").concat(inspect(type2), \"\\\"\")], [node1], [node2]];\n  } // Collect and compare sub-fields. Use the same \"visited fragment names\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n\n  var selectionSet1 = node1.selectionSet;\n  var selectionSet2 = node2.selectionSet;\n  if (selectionSet1 && selectionSet2) {\n    var conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, getNamedType(type1), selectionSet1, getNamedType(type2), selectionSet2);\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\nfunction stringifyArguments(fieldNode) {\n  var _fieldNode$arguments;\n\n  // FIXME https://github.com/graphql/graphql-js/issues/2203\n  var args = /* c8 ignore next */\n  (_fieldNode$arguments = fieldNode.arguments) !== null && _fieldNode$arguments !== void 0 ? _fieldNode$arguments : [];\n  var inputObjectWithArgs = {\n    kind: Kind.OBJECT,\n    fields: args.map(function (argNode) {\n      return {\n        kind: Kind.OBJECT_FIELD,\n        name: argNode.name,\n        value: argNode.value\n      };\n    })\n  };\n  return print(sortValueNode(inputObjectWithArgs));\n} // Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\n\nfunction doTypesConflict(type1, type2) {\n  if (isListType(type1)) {\n    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n  if (isListType(type2)) {\n    return true;\n  }\n  if (isNonNullType(type1)) {\n    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n  if (isNonNullType(type2)) {\n    return true;\n  }\n  if (isLeafType(type1) || isLeafType(type2)) {\n    return type1 !== type2;\n  }\n  return false;\n} // Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\n\nfunction getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {\n  var cached = cachedFieldsAndFragmentNames.get(selectionSet);\n  if (cached) {\n    return cached;\n  }\n  var nodeAndDefs = Object.create(null);\n  var fragmentNames = Object.create(null);\n  _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);\n  var result = [nodeAndDefs, Object.keys(fragmentNames)];\n  cachedFieldsAndFragmentNames.set(selectionSet, result);\n  return result;\n} // Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\n\nfunction getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {\n  // Short-circuit building a type from the node if possible.\n  var cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n  if (cached) {\n    return cached;\n  }\n  var fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);\n  return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);\n}\nfunction _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {\n  var _iterator11 = _createForOfIteratorHelper(selectionSet.selections),\n    _step11;\n  try {\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      var selection = _step11.value;\n      switch (selection.kind) {\n        case Kind.FIELD:\n          {\n            var fieldName = selection.name.value;\n            var fieldDef = void 0;\n            if (isObjectType(parentType) || isInterfaceType(parentType)) {\n              fieldDef = parentType.getFields()[fieldName];\n            }\n            var responseName = selection.alias ? selection.alias.value : fieldName;\n            if (!nodeAndDefs[responseName]) {\n              nodeAndDefs[responseName] = [];\n            }\n            nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\n            break;\n          }\n        case Kind.FRAGMENT_SPREAD:\n          fragmentNames[selection.name.value] = true;\n          break;\n        case Kind.INLINE_FRAGMENT:\n          {\n            var typeCondition = selection.typeCondition;\n            var inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;\n            _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);\n            break;\n          }\n      }\n    }\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n} // Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\n\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\n  if (conflicts.length > 0) {\n    return [[responseName, conflicts.map(function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 1),\n        reason = _ref4[0];\n      return reason;\n    })], [node1].concat(_toConsumableArray(conflicts.map(function (_ref5) {\n      var _ref6 = _slicedToArray(_ref5, 2),\n        fields1 = _ref6[1];\n      return fields1;\n    }).flat())), [node2].concat(_toConsumableArray(conflicts.map(function (_ref7) {\n      var _ref8 = _slicedToArray(_ref7, 3),\n        fields2 = _ref8[2];\n      return fields2;\n    }).flat()))];\n  }\n}\n/**\r\n * A way to keep track of pairs of things when the ordering of the pair does not matter.\r\n */\nvar PairSet = /*#__PURE__*/function () {\n  function PairSet() {\n    _classCallCheck(this, PairSet);\n    this._data = new Map();\n  }\n  _createClass(PairSet, [{\n    key: \"has\",\n    value: function has(a, b, areMutuallyExclusive) {\n      var _this$_data$get;\n      var _ref9 = a < b ? [a, b] : [b, a],\n        _ref10 = _slicedToArray(_ref9, 2),\n        key1 = _ref10[0],\n        key2 = _ref10[1];\n      var result = (_this$_data$get = this._data.get(key1)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(key2);\n      if (result === undefined) {\n        return false;\n      } // areMutuallyExclusive being false is a superset of being true, hence if\n      // we want to know if this PairSet \"has\" these two with no exclusivity,\n      // we have to ensure it was added as such.\n\n      return areMutuallyExclusive ? true : areMutuallyExclusive === result;\n    }\n  }, {\n    key: \"add\",\n    value: function add(a, b, areMutuallyExclusive) {\n      var _ref11 = a < b ? [a, b] : [b, a],\n        _ref12 = _slicedToArray(_ref11, 2),\n        key1 = _ref12[0],\n        key2 = _ref12[1];\n      var map = this._data.get(key1);\n      if (map === undefined) {\n        this._data.set(key1, new Map([[key2, areMutuallyExclusive]]));\n      } else {\n        map.set(key2, areMutuallyExclusive);\n      }\n    }\n  }]);\n  return PairSet;\n}();","map":{"version":3,"names":["inspect","GraphQLError","Kind","print","getNamedType","isInterfaceType","isLeafType","isListType","isNonNullType","isObjectType","sortValueNode","typeFromAST","reasonMessage","reason","Array","isArray","map","_ref","_ref2","_slicedToArray","responseName","subReason","concat","join","OverlappingFieldsCanBeMergedRule","context","comparedFragmentPairs","PairSet","cachedFieldsAndFragmentNames","Map","SelectionSet","selectionSet","conflicts","findConflictsWithinSelectionSet","getParentType","_iterator","_createForOfIteratorHelper","_step","s","n","done","_step$value","value","_step$value$","fields1","fields2","reasonMsg","reportError","nodes","err","e","f","parentType","_getFieldsAndFragment","getFieldsAndFragmentNames","_getFieldsAndFragment2","fieldMap","fragmentNames","collectConflictsWithin","length","i","collectConflictsBetweenFieldsAndFragment","j","collectConflictsBetweenFragments","areMutuallyExclusive","fragmentName","fragment","getFragment","_getReferencedFieldsA","getReferencedFieldsAndFragmentNames","_getReferencedFieldsA2","fieldMap2","referencedFragmentNames","collectConflictsBetween","_iterator2","_step2","referencedFragmentName","has","add","fragmentName1","fragmentName2","fragment1","fragment2","_getReferencedFieldsA3","_getReferencedFieldsA4","fieldMap1","referencedFragmentNames1","_getReferencedFieldsA5","_getReferencedFieldsA6","referencedFragmentNames2","_iterator3","_step3","referencedFragmentName2","_iterator4","_step4","referencedFragmentName1","findConflictsBetweenSubSelectionSets","parentType1","selectionSet1","parentType2","selectionSet2","_getFieldsAndFragment3","_getFieldsAndFragment4","fragmentNames1","_getFieldsAndFragment5","_getFieldsAndFragment6","fragmentNames2","_iterator5","_step5","_iterator6","_step6","_iterator7","_step7","_iterator8","_step8","_i","_Object$entries","Object","entries","_Object$entries$_i","fields","conflict","findConflict","push","parentFieldsAreMutuallyExclusive","_i2","_Object$entries2","_Object$entries2$_i","_iterator9","_step9","field1","_iterator10","_step10","field2","_field","node1","def1","_field2","node2","def2","name1","name","name2","stringifyArguments","type1","type","type2","doTypesConflict","subfieldConflicts","fieldNode","_fieldNode$arguments","args","arguments","inputObjectWithArgs","kind","OBJECT","argNode","OBJECT_FIELD","ofType","cached","get","nodeAndDefs","create","_collectFieldsAndFragmentNames","result","keys","set","fragmentType","getSchema","typeCondition","_iterator11","selections","_step11","selection","FIELD","fieldName","fieldDef","getFields","alias","FRAGMENT_SPREAD","INLINE_FRAGMENT","inlineFragmentType","_ref3","_ref4","_toConsumableArray","_ref5","_ref6","flat","_ref7","_ref8","_classCallCheck","_data","_createClass","key","a","b","_this$_data$get","_ref9","_ref10","key1","key2","undefined","_ref11","_ref12"],"sources":["C:/Users/jared/PortfolioProjects/BookwormSE/Develop/client/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs"],"sourcesContent":["import { inspect } from '../../jsutils/inspect.mjs';\r\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\r\nimport { Kind } from '../../language/kinds.mjs';\r\nimport { print } from '../../language/printer.mjs';\r\nimport {\r\n  getNamedType,\r\n  isInterfaceType,\r\n  isLeafType,\r\n  isListType,\r\n  isNonNullType,\r\n  isObjectType,\r\n} from '../../type/definition.mjs';\r\nimport { sortValueNode } from '../../utilities/sortValueNode.mjs';\r\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\r\n\r\nfunction reasonMessage(reason) {\r\n  if (Array.isArray(reason)) {\r\n    return reason\r\n      .map(\r\n        ([responseName, subReason]) =>\r\n          `subfields \"${responseName}\" conflict because ` +\r\n          reasonMessage(subReason),\r\n      )\r\n      .join(' and ');\r\n  }\r\n\r\n  return reason;\r\n}\r\n/**\r\n * Overlapping fields can be merged\r\n *\r\n * A selection set is only valid if all fields (including spreading any\r\n * fragments) either correspond to distinct response names or can be merged\r\n * without ambiguity.\r\n *\r\n * See https://spec.graphql.org/draft/#sec-Field-Selection-Merging\r\n */\r\n\r\nexport function OverlappingFieldsCanBeMergedRule(context) {\r\n  // A memoization for when two fragments are compared \"between\" each other for\r\n  // conflicts. Two fragments may be compared many times, so memoizing this can\r\n  // dramatically improve the performance of this validator.\r\n  const comparedFragmentPairs = new PairSet(); // A cache for the \"field map\" and list of fragment names found in any given\r\n  // selection set. Selection sets may be asked for this information multiple\r\n  // times, so this improves the performance of this validator.\r\n\r\n  const cachedFieldsAndFragmentNames = new Map();\r\n  return {\r\n    SelectionSet(selectionSet) {\r\n      const conflicts = findConflictsWithinSelectionSet(\r\n        context,\r\n        cachedFieldsAndFragmentNames,\r\n        comparedFragmentPairs,\r\n        context.getParentType(),\r\n        selectionSet,\r\n      );\r\n\r\n      for (const [[responseName, reason], fields1, fields2] of conflicts) {\r\n        const reasonMsg = reasonMessage(reason);\r\n        context.reportError(\r\n          new GraphQLError(\r\n            `Fields \"${responseName}\" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,\r\n            {\r\n              nodes: fields1.concat(fields2),\r\n            },\r\n          ),\r\n        );\r\n      }\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Algorithm:\r\n *\r\n * Conflicts occur when two fields exist in a query which will produce the same\r\n * response name, but represent differing values, thus creating a conflict.\r\n * The algorithm below finds all conflicts via making a series of comparisons\r\n * between fields. In order to compare as few fields as possible, this makes\r\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\r\n *\r\n * Given any selection set, a collection produces both a set of fields by\r\n * also including all inline fragments, as well as a list of fragments\r\n * referenced by fragment spreads.\r\n *\r\n * A) Each selection set represented in the document first compares \"within\" its\r\n * collected set of fields, finding any conflicts between every pair of\r\n * overlapping fields.\r\n * Note: This is the *only time* that a the fields \"within\" a set are compared\r\n * to each other. After this only fields \"between\" sets are compared.\r\n *\r\n * B) Also, if any fragment is referenced in a selection set, then a\r\n * comparison is made \"between\" the original set of fields and the\r\n * referenced fragment.\r\n *\r\n * C) Also, if multiple fragments are referenced, then comparisons\r\n * are made \"between\" each referenced fragment.\r\n *\r\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\r\n * a comparison is made between each field in the original set of fields and\r\n * each field in the the referenced set of fields.\r\n *\r\n * E) Also, if any fragment is referenced in the referenced selection set,\r\n * then a comparison is made \"between\" the original set of fields and the\r\n * referenced fragment (recursively referring to step D).\r\n *\r\n * F) When comparing \"between\" two fragments, first a comparison is made between\r\n * each field in the first referenced set of fields and each field in the the\r\n * second referenced set of fields.\r\n *\r\n * G) Also, any fragments referenced by the first must be compared to the\r\n * second, and any fragments referenced by the second must be compared to the\r\n * first (recursively referring to step F).\r\n *\r\n * H) When comparing two fields, if both have selection sets, then a comparison\r\n * is made \"between\" both selection sets, first comparing the set of fields in\r\n * the first selection set with the set of fields in the second.\r\n *\r\n * I) Also, if any fragment is referenced in either selection set, then a\r\n * comparison is made \"between\" the other set of fields and the\r\n * referenced fragment.\r\n *\r\n * J) Also, if two fragments are referenced in both selection sets, then a\r\n * comparison is made \"between\" the two fragments.\r\n *\r\n */\r\n// Find all conflicts found \"within\" a selection set, including those found\r\n// via spreading in fragments. Called when visiting each SelectionSet in the\r\n// GraphQL Document.\r\nfunction findConflictsWithinSelectionSet(\r\n  context,\r\n  cachedFieldsAndFragmentNames,\r\n  comparedFragmentPairs,\r\n  parentType,\r\n  selectionSet,\r\n) {\r\n  const conflicts = [];\r\n  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(\r\n    context,\r\n    cachedFieldsAndFragmentNames,\r\n    parentType,\r\n    selectionSet,\r\n  ); // (A) Find find all conflicts \"within\" the fields of this selection set.\r\n  // Note: this is the *only place* `collectConflictsWithin` is called.\r\n\r\n  collectConflictsWithin(\r\n    context,\r\n    conflicts,\r\n    cachedFieldsAndFragmentNames,\r\n    comparedFragmentPairs,\r\n    fieldMap,\r\n  );\r\n\r\n  if (fragmentNames.length !== 0) {\r\n    // (B) Then collect conflicts between these fields and those represented by\r\n    // each spread fragment name found.\r\n    for (let i = 0; i < fragmentNames.length; i++) {\r\n      collectConflictsBetweenFieldsAndFragment(\r\n        context,\r\n        conflicts,\r\n        cachedFieldsAndFragmentNames,\r\n        comparedFragmentPairs,\r\n        false,\r\n        fieldMap,\r\n        fragmentNames[i],\r\n      ); // (C) Then compare this fragment with all other fragments found in this\r\n      // selection set to collect conflicts between fragments spread together.\r\n      // This compares each item in the list of fragment names to every other\r\n      // item in that same list (except for itself).\r\n\r\n      for (let j = i + 1; j < fragmentNames.length; j++) {\r\n        collectConflictsBetweenFragments(\r\n          context,\r\n          conflicts,\r\n          cachedFieldsAndFragmentNames,\r\n          comparedFragmentPairs,\r\n          false,\r\n          fragmentNames[i],\r\n          fragmentNames[j],\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  return conflicts;\r\n} // Collect all conflicts found between a set of fields and a fragment reference\r\n// including via spreading in any nested fragments.\r\n\r\nfunction collectConflictsBetweenFieldsAndFragment(\r\n  context,\r\n  conflicts,\r\n  cachedFieldsAndFragmentNames,\r\n  comparedFragmentPairs,\r\n  areMutuallyExclusive,\r\n  fieldMap,\r\n  fragmentName,\r\n) {\r\n  const fragment = context.getFragment(fragmentName);\r\n\r\n  if (!fragment) {\r\n    return;\r\n  }\r\n\r\n  const [fieldMap2, referencedFragmentNames] =\r\n    getReferencedFieldsAndFragmentNames(\r\n      context,\r\n      cachedFieldsAndFragmentNames,\r\n      fragment,\r\n    ); // Do not compare a fragment's fieldMap to itself.\r\n\r\n  if (fieldMap === fieldMap2) {\r\n    return;\r\n  } // (D) First collect any conflicts between the provided collection of fields\r\n  // and the collection of fields represented by the given fragment.\r\n\r\n  collectConflictsBetween(\r\n    context,\r\n    conflicts,\r\n    cachedFieldsAndFragmentNames,\r\n    comparedFragmentPairs,\r\n    areMutuallyExclusive,\r\n    fieldMap,\r\n    fieldMap2,\r\n  ); // (E) Then collect any conflicts between the provided collection of fields\r\n  // and any fragment names found in the given fragment.\r\n\r\n  for (const referencedFragmentName of referencedFragmentNames) {\r\n    // Memoize so two fragments are not compared for conflicts more than once.\r\n    if (\r\n      comparedFragmentPairs.has(\r\n        referencedFragmentName,\r\n        fragmentName,\r\n        areMutuallyExclusive,\r\n      )\r\n    ) {\r\n      continue;\r\n    }\r\n\r\n    comparedFragmentPairs.add(\r\n      referencedFragmentName,\r\n      fragmentName,\r\n      areMutuallyExclusive,\r\n    );\r\n    collectConflictsBetweenFieldsAndFragment(\r\n      context,\r\n      conflicts,\r\n      cachedFieldsAndFragmentNames,\r\n      comparedFragmentPairs,\r\n      areMutuallyExclusive,\r\n      fieldMap,\r\n      referencedFragmentName,\r\n    );\r\n  }\r\n} // Collect all conflicts found between two fragments, including via spreading in\r\n// any nested fragments.\r\n\r\nfunction collectConflictsBetweenFragments(\r\n  context,\r\n  conflicts,\r\n  cachedFieldsAndFragmentNames,\r\n  comparedFragmentPairs,\r\n  areMutuallyExclusive,\r\n  fragmentName1,\r\n  fragmentName2,\r\n) {\r\n  // No need to compare a fragment to itself.\r\n  if (fragmentName1 === fragmentName2) {\r\n    return;\r\n  } // Memoize so two fragments are not compared for conflicts more than once.\r\n\r\n  if (\r\n    comparedFragmentPairs.has(\r\n      fragmentName1,\r\n      fragmentName2,\r\n      areMutuallyExclusive,\r\n    )\r\n  ) {\r\n    return;\r\n  }\r\n\r\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\r\n  const fragment1 = context.getFragment(fragmentName1);\r\n  const fragment2 = context.getFragment(fragmentName2);\r\n\r\n  if (!fragment1 || !fragment2) {\r\n    return;\r\n  }\r\n\r\n  const [fieldMap1, referencedFragmentNames1] =\r\n    getReferencedFieldsAndFragmentNames(\r\n      context,\r\n      cachedFieldsAndFragmentNames,\r\n      fragment1,\r\n    );\r\n  const [fieldMap2, referencedFragmentNames2] =\r\n    getReferencedFieldsAndFragmentNames(\r\n      context,\r\n      cachedFieldsAndFragmentNames,\r\n      fragment2,\r\n    ); // (F) First, collect all conflicts between these two collections of fields\r\n  // (not including any nested fragments).\r\n\r\n  collectConflictsBetween(\r\n    context,\r\n    conflicts,\r\n    cachedFieldsAndFragmentNames,\r\n    comparedFragmentPairs,\r\n    areMutuallyExclusive,\r\n    fieldMap1,\r\n    fieldMap2,\r\n  ); // (G) Then collect conflicts between the first fragment and any nested\r\n  // fragments spread in the second fragment.\r\n\r\n  for (const referencedFragmentName2 of referencedFragmentNames2) {\r\n    collectConflictsBetweenFragments(\r\n      context,\r\n      conflicts,\r\n      cachedFieldsAndFragmentNames,\r\n      comparedFragmentPairs,\r\n      areMutuallyExclusive,\r\n      fragmentName1,\r\n      referencedFragmentName2,\r\n    );\r\n  } // (G) Then collect conflicts between the second fragment and any nested\r\n  // fragments spread in the first fragment.\r\n\r\n  for (const referencedFragmentName1 of referencedFragmentNames1) {\r\n    collectConflictsBetweenFragments(\r\n      context,\r\n      conflicts,\r\n      cachedFieldsAndFragmentNames,\r\n      comparedFragmentPairs,\r\n      areMutuallyExclusive,\r\n      referencedFragmentName1,\r\n      fragmentName2,\r\n    );\r\n  }\r\n} // Find all conflicts found between two selection sets, including those found\r\n// via spreading in fragments. Called when determining if conflicts exist\r\n// between the sub-fields of two overlapping fields.\r\n\r\nfunction findConflictsBetweenSubSelectionSets(\r\n  context,\r\n  cachedFieldsAndFragmentNames,\r\n  comparedFragmentPairs,\r\n  areMutuallyExclusive,\r\n  parentType1,\r\n  selectionSet1,\r\n  parentType2,\r\n  selectionSet2,\r\n) {\r\n  const conflicts = [];\r\n  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(\r\n    context,\r\n    cachedFieldsAndFragmentNames,\r\n    parentType1,\r\n    selectionSet1,\r\n  );\r\n  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(\r\n    context,\r\n    cachedFieldsAndFragmentNames,\r\n    parentType2,\r\n    selectionSet2,\r\n  ); // (H) First, collect all conflicts between these two collections of field.\r\n\r\n  collectConflictsBetween(\r\n    context,\r\n    conflicts,\r\n    cachedFieldsAndFragmentNames,\r\n    comparedFragmentPairs,\r\n    areMutuallyExclusive,\r\n    fieldMap1,\r\n    fieldMap2,\r\n  ); // (I) Then collect conflicts between the first collection of fields and\r\n  // those referenced by each fragment name associated with the second.\r\n\r\n  for (const fragmentName2 of fragmentNames2) {\r\n    collectConflictsBetweenFieldsAndFragment(\r\n      context,\r\n      conflicts,\r\n      cachedFieldsAndFragmentNames,\r\n      comparedFragmentPairs,\r\n      areMutuallyExclusive,\r\n      fieldMap1,\r\n      fragmentName2,\r\n    );\r\n  } // (I) Then collect conflicts between the second collection of fields and\r\n  // those referenced by each fragment name associated with the first.\r\n\r\n  for (const fragmentName1 of fragmentNames1) {\r\n    collectConflictsBetweenFieldsAndFragment(\r\n      context,\r\n      conflicts,\r\n      cachedFieldsAndFragmentNames,\r\n      comparedFragmentPairs,\r\n      areMutuallyExclusive,\r\n      fieldMap2,\r\n      fragmentName1,\r\n    );\r\n  } // (J) Also collect conflicts between any fragment names by the first and\r\n  // fragment names by the second. This compares each item in the first set of\r\n  // names to each item in the second set of names.\r\n\r\n  for (const fragmentName1 of fragmentNames1) {\r\n    for (const fragmentName2 of fragmentNames2) {\r\n      collectConflictsBetweenFragments(\r\n        context,\r\n        conflicts,\r\n        cachedFieldsAndFragmentNames,\r\n        comparedFragmentPairs,\r\n        areMutuallyExclusive,\r\n        fragmentName1,\r\n        fragmentName2,\r\n      );\r\n    }\r\n  }\r\n\r\n  return conflicts;\r\n} // Collect all Conflicts \"within\" one collection of fields.\r\n\r\nfunction collectConflictsWithin(\r\n  context,\r\n  conflicts,\r\n  cachedFieldsAndFragmentNames,\r\n  comparedFragmentPairs,\r\n  fieldMap,\r\n) {\r\n  // A field map is a keyed collection, where each key represents a response\r\n  // name and the value at that key is a list of all fields which provide that\r\n  // response name. For every response name, if there are multiple fields, they\r\n  // must be compared to find a potential conflict.\r\n  for (const [responseName, fields] of Object.entries(fieldMap)) {\r\n    // This compares every field in the list to every other field in this list\r\n    // (except to itself). If the list only has one item, nothing needs to\r\n    // be compared.\r\n    if (fields.length > 1) {\r\n      for (let i = 0; i < fields.length; i++) {\r\n        for (let j = i + 1; j < fields.length; j++) {\r\n          const conflict = findConflict(\r\n            context,\r\n            cachedFieldsAndFragmentNames,\r\n            comparedFragmentPairs,\r\n            false, // within one collection is never mutually exclusive\r\n            responseName,\r\n            fields[i],\r\n            fields[j],\r\n          );\r\n\r\n          if (conflict) {\r\n            conflicts.push(conflict);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n} // Collect all Conflicts between two collections of fields. This is similar to,\r\n// but different from the `collectConflictsWithin` function above. This check\r\n// assumes that `collectConflictsWithin` has already been called on each\r\n// provided collection of fields. This is true because this validator traverses\r\n// each individual selection set.\r\n\r\nfunction collectConflictsBetween(\r\n  context,\r\n  conflicts,\r\n  cachedFieldsAndFragmentNames,\r\n  comparedFragmentPairs,\r\n  parentFieldsAreMutuallyExclusive,\r\n  fieldMap1,\r\n  fieldMap2,\r\n) {\r\n  // A field map is a keyed collection, where each key represents a response\r\n  // name and the value at that key is a list of all fields which provide that\r\n  // response name. For any response name which appears in both provided field\r\n  // maps, each field from the first field map must be compared to every field\r\n  // in the second field map to find potential conflicts.\r\n  for (const [responseName, fields1] of Object.entries(fieldMap1)) {\r\n    const fields2 = fieldMap2[responseName];\r\n\r\n    if (fields2) {\r\n      for (const field1 of fields1) {\r\n        for (const field2 of fields2) {\r\n          const conflict = findConflict(\r\n            context,\r\n            cachedFieldsAndFragmentNames,\r\n            comparedFragmentPairs,\r\n            parentFieldsAreMutuallyExclusive,\r\n            responseName,\r\n            field1,\r\n            field2,\r\n          );\r\n\r\n          if (conflict) {\r\n            conflicts.push(conflict);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n} // Determines if there is a conflict between two particular fields, including\r\n// comparing their sub-fields.\r\n\r\nfunction findConflict(\r\n  context,\r\n  cachedFieldsAndFragmentNames,\r\n  comparedFragmentPairs,\r\n  parentFieldsAreMutuallyExclusive,\r\n  responseName,\r\n  field1,\r\n  field2,\r\n) {\r\n  const [parentType1, node1, def1] = field1;\r\n  const [parentType2, node2, def2] = field2; // If it is known that two fields could not possibly apply at the same\r\n  // time, due to the parent types, then it is safe to permit them to diverge\r\n  // in aliased field or arguments used as they will not present any ambiguity\r\n  // by differing.\r\n  // It is known that two parent types could never overlap if they are\r\n  // different Object types. Interface or Union types might overlap - if not\r\n  // in the current state of the schema, then perhaps in some future version,\r\n  // thus may not safely diverge.\r\n\r\n  const areMutuallyExclusive =\r\n    parentFieldsAreMutuallyExclusive ||\r\n    (parentType1 !== parentType2 &&\r\n      isObjectType(parentType1) &&\r\n      isObjectType(parentType2));\r\n\r\n  if (!areMutuallyExclusive) {\r\n    // Two aliases must refer to the same field.\r\n    const name1 = node1.name.value;\r\n    const name2 = node2.name.value;\r\n\r\n    if (name1 !== name2) {\r\n      return [\r\n        [responseName, `\"${name1}\" and \"${name2}\" are different fields`],\r\n        [node1],\r\n        [node2],\r\n      ];\r\n    } // Two field calls must have the same arguments.\r\n\r\n    if (stringifyArguments(node1) !== stringifyArguments(node2)) {\r\n      return [\r\n        [responseName, 'they have differing arguments'],\r\n        [node1],\r\n        [node2],\r\n      ];\r\n    }\r\n  } // The return type for each field.\r\n\r\n  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;\r\n  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;\r\n\r\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\r\n    return [\r\n      [\r\n        responseName,\r\n        `they return conflicting types \"${inspect(type1)}\" and \"${inspect(\r\n          type2,\r\n        )}\"`,\r\n      ],\r\n      [node1],\r\n      [node2],\r\n    ];\r\n  } // Collect and compare sub-fields. Use the same \"visited fragment names\" list\r\n  // for both collections so fields in a fragment reference are never\r\n  // compared to themselves.\r\n\r\n  const selectionSet1 = node1.selectionSet;\r\n  const selectionSet2 = node2.selectionSet;\r\n\r\n  if (selectionSet1 && selectionSet2) {\r\n    const conflicts = findConflictsBetweenSubSelectionSets(\r\n      context,\r\n      cachedFieldsAndFragmentNames,\r\n      comparedFragmentPairs,\r\n      areMutuallyExclusive,\r\n      getNamedType(type1),\r\n      selectionSet1,\r\n      getNamedType(type2),\r\n      selectionSet2,\r\n    );\r\n    return subfieldConflicts(conflicts, responseName, node1, node2);\r\n  }\r\n}\r\n\r\nfunction stringifyArguments(fieldNode) {\r\n  var _fieldNode$arguments;\r\n\r\n  // FIXME https://github.com/graphql/graphql-js/issues/2203\r\n  const args =\r\n    /* c8 ignore next */\r\n    (_fieldNode$arguments = fieldNode.arguments) !== null &&\r\n    _fieldNode$arguments !== void 0\r\n      ? _fieldNode$arguments\r\n      : [];\r\n  const inputObjectWithArgs = {\r\n    kind: Kind.OBJECT,\r\n    fields: args.map((argNode) => ({\r\n      kind: Kind.OBJECT_FIELD,\r\n      name: argNode.name,\r\n      value: argNode.value,\r\n    })),\r\n  };\r\n  return print(sortValueNode(inputObjectWithArgs));\r\n} // Two types conflict if both types could not apply to a value simultaneously.\r\n// Composite types are ignored as their individual field types will be compared\r\n// later recursively. However List and Non-Null types must match.\r\n\r\nfunction doTypesConflict(type1, type2) {\r\n  if (isListType(type1)) {\r\n    return isListType(type2)\r\n      ? doTypesConflict(type1.ofType, type2.ofType)\r\n      : true;\r\n  }\r\n\r\n  if (isListType(type2)) {\r\n    return true;\r\n  }\r\n\r\n  if (isNonNullType(type1)) {\r\n    return isNonNullType(type2)\r\n      ? doTypesConflict(type1.ofType, type2.ofType)\r\n      : true;\r\n  }\r\n\r\n  if (isNonNullType(type2)) {\r\n    return true;\r\n  }\r\n\r\n  if (isLeafType(type1) || isLeafType(type2)) {\r\n    return type1 !== type2;\r\n  }\r\n\r\n  return false;\r\n} // Given a selection set, return the collection of fields (a mapping of response\r\n// name to field nodes and definitions) as well as a list of fragment names\r\n// referenced via fragment spreads.\r\n\r\nfunction getFieldsAndFragmentNames(\r\n  context,\r\n  cachedFieldsAndFragmentNames,\r\n  parentType,\r\n  selectionSet,\r\n) {\r\n  const cached = cachedFieldsAndFragmentNames.get(selectionSet);\r\n\r\n  if (cached) {\r\n    return cached;\r\n  }\r\n\r\n  const nodeAndDefs = Object.create(null);\r\n  const fragmentNames = Object.create(null);\r\n\r\n  _collectFieldsAndFragmentNames(\r\n    context,\r\n    parentType,\r\n    selectionSet,\r\n    nodeAndDefs,\r\n    fragmentNames,\r\n  );\r\n\r\n  const result = [nodeAndDefs, Object.keys(fragmentNames)];\r\n  cachedFieldsAndFragmentNames.set(selectionSet, result);\r\n  return result;\r\n} // Given a reference to a fragment, return the represented collection of fields\r\n// as well as a list of nested fragment names referenced via fragment spreads.\r\n\r\nfunction getReferencedFieldsAndFragmentNames(\r\n  context,\r\n  cachedFieldsAndFragmentNames,\r\n  fragment,\r\n) {\r\n  // Short-circuit building a type from the node if possible.\r\n  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\r\n\r\n  if (cached) {\r\n    return cached;\r\n  }\r\n\r\n  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);\r\n  return getFieldsAndFragmentNames(\r\n    context,\r\n    cachedFieldsAndFragmentNames,\r\n    fragmentType,\r\n    fragment.selectionSet,\r\n  );\r\n}\r\n\r\nfunction _collectFieldsAndFragmentNames(\r\n  context,\r\n  parentType,\r\n  selectionSet,\r\n  nodeAndDefs,\r\n  fragmentNames,\r\n) {\r\n  for (const selection of selectionSet.selections) {\r\n    switch (selection.kind) {\r\n      case Kind.FIELD: {\r\n        const fieldName = selection.name.value;\r\n        let fieldDef;\r\n\r\n        if (isObjectType(parentType) || isInterfaceType(parentType)) {\r\n          fieldDef = parentType.getFields()[fieldName];\r\n        }\r\n\r\n        const responseName = selection.alias\r\n          ? selection.alias.value\r\n          : fieldName;\r\n\r\n        if (!nodeAndDefs[responseName]) {\r\n          nodeAndDefs[responseName] = [];\r\n        }\r\n\r\n        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\r\n        break;\r\n      }\r\n\r\n      case Kind.FRAGMENT_SPREAD:\r\n        fragmentNames[selection.name.value] = true;\r\n        break;\r\n\r\n      case Kind.INLINE_FRAGMENT: {\r\n        const typeCondition = selection.typeCondition;\r\n        const inlineFragmentType = typeCondition\r\n          ? typeFromAST(context.getSchema(), typeCondition)\r\n          : parentType;\r\n\r\n        _collectFieldsAndFragmentNames(\r\n          context,\r\n          inlineFragmentType,\r\n          selection.selectionSet,\r\n          nodeAndDefs,\r\n          fragmentNames,\r\n        );\r\n\r\n        break;\r\n      }\r\n    }\r\n  }\r\n} // Given a series of Conflicts which occurred between two sub-fields, generate\r\n// a single Conflict.\r\n\r\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\r\n  if (conflicts.length > 0) {\r\n    return [\r\n      [responseName, conflicts.map(([reason]) => reason)],\r\n      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],\r\n      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()],\r\n    ];\r\n  }\r\n}\r\n/**\r\n * A way to keep track of pairs of things when the ordering of the pair does not matter.\r\n */\r\n\r\nclass PairSet {\r\n  constructor() {\r\n    this._data = new Map();\r\n  }\r\n\r\n  has(a, b, areMutuallyExclusive) {\r\n    var _this$_data$get;\r\n\r\n    const [key1, key2] = a < b ? [a, b] : [b, a];\r\n    const result =\r\n      (_this$_data$get = this._data.get(key1)) === null ||\r\n      _this$_data$get === void 0\r\n        ? void 0\r\n        : _this$_data$get.get(key2);\r\n\r\n    if (result === undefined) {\r\n      return false;\r\n    } // areMutuallyExclusive being false is a superset of being true, hence if\r\n    // we want to know if this PairSet \"has\" these two with no exclusivity,\r\n    // we have to ensure it was added as such.\r\n\r\n    return areMutuallyExclusive ? true : areMutuallyExclusive === result;\r\n  }\r\n\r\n  add(a, b, areMutuallyExclusive) {\r\n    const [key1, key2] = a < b ? [a, b] : [b, a];\r\n\r\n    const map = this._data.get(key1);\r\n\r\n    if (map === undefined) {\r\n      this._data.set(key1, new Map([[key2, areMutuallyExclusive]]));\r\n    } else {\r\n      map.set(key2, areMutuallyExclusive);\r\n    }\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}