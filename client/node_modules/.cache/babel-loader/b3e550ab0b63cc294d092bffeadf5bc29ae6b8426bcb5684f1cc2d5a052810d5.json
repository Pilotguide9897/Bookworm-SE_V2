{"ast":null,"code":"import _classCallCheck from \"C:/Users/jared/PortfolioProjects/BookwormSE/Develop/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/jared/PortfolioProjects/BookwormSE/Develop/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { syntaxError } from '../error/syntaxError.mjs';\nimport { Location, OperationTypeNode } from './ast.mjs';\nimport { DirectiveLocation } from './directiveLocation.mjs';\nimport { Kind } from './kinds.mjs';\nimport { isPunctuatorTokenKind, Lexer } from './lexer.mjs';\nimport { isSource, Source } from './source.mjs';\nimport { TokenKind } from './tokenKind.mjs';\n/**\r\n * Configuration options to control parser behavior\r\n */\n\n/**\r\n * Given a GraphQL source, parses it into a Document.\r\n * Throws GraphQLError if a syntax error is encountered.\r\n */\nexport function parse(source, options) {\n  var parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n/**\r\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\r\n * that value.\r\n * Throws GraphQLError if a syntax error is encountered.\r\n *\r\n * This is useful within tools that operate upon GraphQL Values directly and\r\n * in isolation of complete GraphQL documents.\r\n *\r\n * Consider providing the results to the utility function: valueFromAST().\r\n */\n\nexport function parseValue(source, options) {\n  var parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  var value = parser.parseValueLiteral(false);\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\r\n * Similar to parseValue(), but raises a parse error if it encounters a\r\n * variable. The return type will be a constant value.\r\n */\n\nexport function parseConstValue(source, options) {\n  var parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  var value = parser.parseConstValueLiteral();\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\r\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\r\n * that type.\r\n * Throws GraphQLError if a syntax error is encountered.\r\n *\r\n * This is useful within tools that operate upon GraphQL Types directly and\r\n * in isolation of complete GraphQL documents.\r\n *\r\n * Consider providing the results to the utility function: typeFromAST().\r\n */\n\nexport function parseType(source, options) {\n  var parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  var type = parser.parseTypeReference();\n  parser.expectToken(TokenKind.EOF);\n  return type;\n}\n/**\r\n * This class is exported only to assist people in implementing their own parsers\r\n * without duplicating too much code and should be used only as last resort for cases\r\n * such as experimental syntax or if certain features could not be contributed upstream.\r\n *\r\n * It is still part of the internal API and is versioned, so any changes to it are never\r\n * considered breaking changes. If you still need to support multiple versions of the\r\n * library, please use the `versionInfo` variable for version detection.\r\n *\r\n * @internal\r\n */\n\nexport var Parser = /*#__PURE__*/function () {\n  function Parser(source) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, Parser);\n    var sourceObj = isSource(source) ? source : new Source(source);\n    this._lexer = new Lexer(sourceObj);\n    this._options = options;\n    this._tokenCounter = 0;\n  }\n  /**\r\n   * Converts a name lex token into a name parse node.\r\n   */\n  _createClass(Parser, [{\n    key: \"parseName\",\n    value: function parseName() {\n      var token = this.expectToken(TokenKind.NAME);\n      return this.node(token, {\n        kind: Kind.NAME,\n        value: token.value\n      });\n    } // Implements the parsing rules in the Document section.\n\n    /**\r\n     * Document : Definition+\r\n     */\n  }, {\n    key: \"parseDocument\",\n    value: function parseDocument() {\n      return this.node(this._lexer.token, {\n        kind: Kind.DOCUMENT,\n        definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF)\n      });\n    }\n    /**\r\n     * Definition :\r\n     *   - ExecutableDefinition\r\n     *   - TypeSystemDefinition\r\n     *   - TypeSystemExtension\r\n     *\r\n     * ExecutableDefinition :\r\n     *   - OperationDefinition\r\n     *   - FragmentDefinition\r\n     *\r\n     * TypeSystemDefinition :\r\n     *   - SchemaDefinition\r\n     *   - TypeDefinition\r\n     *   - DirectiveDefinition\r\n     *\r\n     * TypeDefinition :\r\n     *   - ScalarTypeDefinition\r\n     *   - ObjectTypeDefinition\r\n     *   - InterfaceTypeDefinition\r\n     *   - UnionTypeDefinition\r\n     *   - EnumTypeDefinition\r\n     *   - InputObjectTypeDefinition\r\n     */\n  }, {\n    key: \"parseDefinition\",\n    value: function parseDefinition() {\n      if (this.peek(TokenKind.BRACE_L)) {\n        return this.parseOperationDefinition();\n      } // Many definitions begin with a description and require a lookahead.\n\n      var hasDescription = this.peekDescription();\n      var keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;\n      if (keywordToken.kind === TokenKind.NAME) {\n        switch (keywordToken.value) {\n          case 'schema':\n            return this.parseSchemaDefinition();\n          case 'scalar':\n            return this.parseScalarTypeDefinition();\n          case 'type':\n            return this.parseObjectTypeDefinition();\n          case 'interface':\n            return this.parseInterfaceTypeDefinition();\n          case 'union':\n            return this.parseUnionTypeDefinition();\n          case 'enum':\n            return this.parseEnumTypeDefinition();\n          case 'input':\n            return this.parseInputObjectTypeDefinition();\n          case 'directive':\n            return this.parseDirectiveDefinition();\n        }\n        if (hasDescription) {\n          throw syntaxError(this._lexer.source, this._lexer.token.start, 'Unexpected description, descriptions are supported only on type definitions.');\n        }\n        switch (keywordToken.value) {\n          case 'query':\n          case 'mutation':\n          case 'subscription':\n            return this.parseOperationDefinition();\n          case 'fragment':\n            return this.parseFragmentDefinition();\n          case 'extend':\n            return this.parseTypeSystemExtension();\n        }\n      }\n      throw this.unexpected(keywordToken);\n    } // Implements the parsing rules in the Operations section.\n\n    /**\r\n     * OperationDefinition :\r\n     *  - SelectionSet\r\n     *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\r\n     */\n  }, {\n    key: \"parseOperationDefinition\",\n    value: function parseOperationDefinition() {\n      var start = this._lexer.token;\n      if (this.peek(TokenKind.BRACE_L)) {\n        return this.node(start, {\n          kind: Kind.OPERATION_DEFINITION,\n          operation: OperationTypeNode.QUERY,\n          name: undefined,\n          variableDefinitions: [],\n          directives: [],\n          selectionSet: this.parseSelectionSet()\n        });\n      }\n      var operation = this.parseOperationType();\n      var name;\n      if (this.peek(TokenKind.NAME)) {\n        name = this.parseName();\n      }\n      return this.node(start, {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: operation,\n        name: name,\n        variableDefinitions: this.parseVariableDefinitions(),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet()\n      });\n    }\n    /**\r\n     * OperationType : one of query mutation subscription\r\n     */\n  }, {\n    key: \"parseOperationType\",\n    value: function parseOperationType() {\n      var operationToken = this.expectToken(TokenKind.NAME);\n      switch (operationToken.value) {\n        case 'query':\n          return OperationTypeNode.QUERY;\n        case 'mutation':\n          return OperationTypeNode.MUTATION;\n        case 'subscription':\n          return OperationTypeNode.SUBSCRIPTION;\n      }\n      throw this.unexpected(operationToken);\n    }\n    /**\r\n     * VariableDefinitions : ( VariableDefinition+ )\r\n     */\n  }, {\n    key: \"parseVariableDefinitions\",\n    value: function parseVariableDefinitions() {\n      return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);\n    }\n    /**\r\n     * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\r\n     */\n  }, {\n    key: \"parseVariableDefinition\",\n    value: function parseVariableDefinition() {\n      return this.node(this._lexer.token, {\n        kind: Kind.VARIABLE_DEFINITION,\n        variable: this.parseVariable(),\n        type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\n        defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : undefined,\n        directives: this.parseConstDirectives()\n      });\n    }\n    /**\r\n     * Variable : $ Name\r\n     */\n  }, {\n    key: \"parseVariable\",\n    value: function parseVariable() {\n      var start = this._lexer.token;\n      this.expectToken(TokenKind.DOLLAR);\n      return this.node(start, {\n        kind: Kind.VARIABLE,\n        name: this.parseName()\n      });\n    }\n    /**\r\n     * ```\r\n     * SelectionSet : { Selection+ }\r\n     * ```\r\n     */\n  }, {\n    key: \"parseSelectionSet\",\n    value: function parseSelectionSet() {\n      return this.node(this._lexer.token, {\n        kind: Kind.SELECTION_SET,\n        selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R)\n      });\n    }\n    /**\r\n     * Selection :\r\n     *   - Field\r\n     *   - FragmentSpread\r\n     *   - InlineFragment\r\n     */\n  }, {\n    key: \"parseSelection\",\n    value: function parseSelection() {\n      return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();\n    }\n    /**\r\n     * Field : Alias? Name Arguments? Directives? SelectionSet?\r\n     *\r\n     * Alias : Name :\r\n     */\n  }, {\n    key: \"parseField\",\n    value: function parseField() {\n      var start = this._lexer.token;\n      var nameOrAlias = this.parseName();\n      var alias;\n      var name;\n      if (this.expectOptionalToken(TokenKind.COLON)) {\n        alias = nameOrAlias;\n        name = this.parseName();\n      } else {\n        name = nameOrAlias;\n      }\n      return this.node(start, {\n        kind: Kind.FIELD,\n        alias: alias,\n        name: name,\n        arguments: this.parseArguments(false),\n        directives: this.parseDirectives(false),\n        selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined\n      });\n    }\n    /**\r\n     * Arguments[Const] : ( Argument[?Const]+ )\r\n     */\n  }, {\n    key: \"parseArguments\",\n    value: function parseArguments(isConst) {\n      var item = isConst ? this.parseConstArgument : this.parseArgument;\n      return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\n    }\n    /**\r\n     * Argument[Const] : Name : Value[?Const]\r\n     */\n  }, {\n    key: \"parseArgument\",\n    value: function parseArgument() {\n      var isConst = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var start = this._lexer.token;\n      var name = this.parseName();\n      this.expectToken(TokenKind.COLON);\n      return this.node(start, {\n        kind: Kind.ARGUMENT,\n        name: name,\n        value: this.parseValueLiteral(isConst)\n      });\n    }\n  }, {\n    key: \"parseConstArgument\",\n    value: function parseConstArgument() {\n      return this.parseArgument(true);\n    } // Implements the parsing rules in the Fragments section.\n\n    /**\r\n     * Corresponds to both FragmentSpread and InlineFragment in the spec.\r\n     *\r\n     * FragmentSpread : ... FragmentName Directives?\r\n     *\r\n     * InlineFragment : ... TypeCondition? Directives? SelectionSet\r\n     */\n  }, {\n    key: \"parseFragment\",\n    value: function parseFragment() {\n      var start = this._lexer.token;\n      this.expectToken(TokenKind.SPREAD);\n      var hasTypeCondition = this.expectOptionalKeyword('on');\n      if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\n        return this.node(start, {\n          kind: Kind.FRAGMENT_SPREAD,\n          name: this.parseFragmentName(),\n          directives: this.parseDirectives(false)\n        });\n      }\n      return this.node(start, {\n        kind: Kind.INLINE_FRAGMENT,\n        typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet()\n      });\n    }\n    /**\r\n     * FragmentDefinition :\r\n     *   - fragment FragmentName on TypeCondition Directives? SelectionSet\r\n     *\r\n     * TypeCondition : NamedType\r\n     */\n  }, {\n    key: \"parseFragmentDefinition\",\n    value: function parseFragmentDefinition() {\n      var start = this._lexer.token;\n      this.expectKeyword('fragment'); // Legacy support for defining variables within fragments changes\n      // the grammar of FragmentDefinition:\n      //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n      if (this._options.allowLegacyFragmentVariables === true) {\n        return this.node(start, {\n          kind: Kind.FRAGMENT_DEFINITION,\n          name: this.parseFragmentName(),\n          variableDefinitions: this.parseVariableDefinitions(),\n          typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n          directives: this.parseDirectives(false),\n          selectionSet: this.parseSelectionSet()\n        });\n      }\n      return this.node(start, {\n        kind: Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet()\n      });\n    }\n    /**\r\n     * FragmentName : Name but not `on`\r\n     */\n  }, {\n    key: \"parseFragmentName\",\n    value: function parseFragmentName() {\n      if (this._lexer.token.value === 'on') {\n        throw this.unexpected();\n      }\n      return this.parseName();\n    } // Implements the parsing rules in the Values section.\n\n    /**\r\n     * Value[Const] :\r\n     *   - [~Const] Variable\r\n     *   - IntValue\r\n     *   - FloatValue\r\n     *   - StringValue\r\n     *   - BooleanValue\r\n     *   - NullValue\r\n     *   - EnumValue\r\n     *   - ListValue[?Const]\r\n     *   - ObjectValue[?Const]\r\n     *\r\n     * BooleanValue : one of `true` `false`\r\n     *\r\n     * NullValue : `null`\r\n     *\r\n     * EnumValue : Name but not `true`, `false` or `null`\r\n     */\n  }, {\n    key: \"parseValueLiteral\",\n    value: function parseValueLiteral(isConst) {\n      var token = this._lexer.token;\n      switch (token.kind) {\n        case TokenKind.BRACKET_L:\n          return this.parseList(isConst);\n        case TokenKind.BRACE_L:\n          return this.parseObject(isConst);\n        case TokenKind.INT:\n          this.advanceLexer();\n          return this.node(token, {\n            kind: Kind.INT,\n            value: token.value\n          });\n        case TokenKind.FLOAT:\n          this.advanceLexer();\n          return this.node(token, {\n            kind: Kind.FLOAT,\n            value: token.value\n          });\n        case TokenKind.STRING:\n        case TokenKind.BLOCK_STRING:\n          return this.parseStringLiteral();\n        case TokenKind.NAME:\n          this.advanceLexer();\n          switch (token.value) {\n            case 'true':\n              return this.node(token, {\n                kind: Kind.BOOLEAN,\n                value: true\n              });\n            case 'false':\n              return this.node(token, {\n                kind: Kind.BOOLEAN,\n                value: false\n              });\n            case 'null':\n              return this.node(token, {\n                kind: Kind.NULL\n              });\n            default:\n              return this.node(token, {\n                kind: Kind.ENUM,\n                value: token.value\n              });\n          }\n        case TokenKind.DOLLAR:\n          if (isConst) {\n            this.expectToken(TokenKind.DOLLAR);\n            if (this._lexer.token.kind === TokenKind.NAME) {\n              var varName = this._lexer.token.value;\n              throw syntaxError(this._lexer.source, token.start, \"Unexpected variable \\\"$\".concat(varName, \"\\\" in constant value.\"));\n            } else {\n              throw this.unexpected(token);\n            }\n          }\n          return this.parseVariable();\n        default:\n          throw this.unexpected();\n      }\n    }\n  }, {\n    key: \"parseConstValueLiteral\",\n    value: function parseConstValueLiteral() {\n      return this.parseValueLiteral(true);\n    }\n  }, {\n    key: \"parseStringLiteral\",\n    value: function parseStringLiteral() {\n      var token = this._lexer.token;\n      this.advanceLexer();\n      return this.node(token, {\n        kind: Kind.STRING,\n        value: token.value,\n        block: token.kind === TokenKind.BLOCK_STRING\n      });\n    }\n    /**\r\n     * ListValue[Const] :\r\n     *   - [ ]\r\n     *   - [ Value[?Const]+ ]\r\n     */\n  }, {\n    key: \"parseList\",\n    value: function parseList(isConst) {\n      var _this = this;\n      var item = function item() {\n        return _this.parseValueLiteral(isConst);\n      };\n      return this.node(this._lexer.token, {\n        kind: Kind.LIST,\n        values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)\n      });\n    }\n    /**\r\n     * ```\r\n     * ObjectValue[Const] :\r\n     *   - { }\r\n     *   - { ObjectField[?Const]+ }\r\n     * ```\r\n     */\n  }, {\n    key: \"parseObject\",\n    value: function parseObject(isConst) {\n      var _this2 = this;\n      var item = function item() {\n        return _this2.parseObjectField(isConst);\n      };\n      return this.node(this._lexer.token, {\n        kind: Kind.OBJECT,\n        fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)\n      });\n    }\n    /**\r\n     * ObjectField[Const] : Name : Value[?Const]\r\n     */\n  }, {\n    key: \"parseObjectField\",\n    value: function parseObjectField(isConst) {\n      var start = this._lexer.token;\n      var name = this.parseName();\n      this.expectToken(TokenKind.COLON);\n      return this.node(start, {\n        kind: Kind.OBJECT_FIELD,\n        name: name,\n        value: this.parseValueLiteral(isConst)\n      });\n    } // Implements the parsing rules in the Directives section.\n\n    /**\r\n     * Directives[Const] : Directive[?Const]+\r\n     */\n  }, {\n    key: \"parseDirectives\",\n    value: function parseDirectives(isConst) {\n      var directives = [];\n      while (this.peek(TokenKind.AT)) {\n        directives.push(this.parseDirective(isConst));\n      }\n      return directives;\n    }\n  }, {\n    key: \"parseConstDirectives\",\n    value: function parseConstDirectives() {\n      return this.parseDirectives(true);\n    }\n    /**\r\n     * ```\r\n     * Directive[Const] : @ Name Arguments[?Const]?\r\n     * ```\r\n     */\n  }, {\n    key: \"parseDirective\",\n    value: function parseDirective(isConst) {\n      var start = this._lexer.token;\n      this.expectToken(TokenKind.AT);\n      return this.node(start, {\n        kind: Kind.DIRECTIVE,\n        name: this.parseName(),\n        arguments: this.parseArguments(isConst)\n      });\n    } // Implements the parsing rules in the Types section.\n\n    /**\r\n     * Type :\r\n     *   - NamedType\r\n     *   - ListType\r\n     *   - NonNullType\r\n     */\n  }, {\n    key: \"parseTypeReference\",\n    value: function parseTypeReference() {\n      var start = this._lexer.token;\n      var type;\n      if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\n        var innerType = this.parseTypeReference();\n        this.expectToken(TokenKind.BRACKET_R);\n        type = this.node(start, {\n          kind: Kind.LIST_TYPE,\n          type: innerType\n        });\n      } else {\n        type = this.parseNamedType();\n      }\n      if (this.expectOptionalToken(TokenKind.BANG)) {\n        return this.node(start, {\n          kind: Kind.NON_NULL_TYPE,\n          type: type\n        });\n      }\n      return type;\n    }\n    /**\r\n     * NamedType : Name\r\n     */\n  }, {\n    key: \"parseNamedType\",\n    value: function parseNamedType() {\n      return this.node(this._lexer.token, {\n        kind: Kind.NAMED_TYPE,\n        name: this.parseName()\n      });\n    } // Implements the parsing rules in the Type Definition section.\n  }, {\n    key: \"peekDescription\",\n    value: function peekDescription() {\n      return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\n    }\n    /**\r\n     * Description : StringValue\r\n     */\n  }, {\n    key: \"parseDescription\",\n    value: function parseDescription() {\n      if (this.peekDescription()) {\n        return this.parseStringLiteral();\n      }\n    }\n    /**\r\n     * ```\r\n     * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\r\n     * ```\r\n     */\n  }, {\n    key: \"parseSchemaDefinition\",\n    value: function parseSchemaDefinition() {\n      var start = this._lexer.token;\n      var description = this.parseDescription();\n      this.expectKeyword('schema');\n      var directives = this.parseConstDirectives();\n      var operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n      return this.node(start, {\n        kind: Kind.SCHEMA_DEFINITION,\n        description: description,\n        directives: directives,\n        operationTypes: operationTypes\n      });\n    }\n    /**\r\n     * OperationTypeDefinition : OperationType : NamedType\r\n     */\n  }, {\n    key: \"parseOperationTypeDefinition\",\n    value: function parseOperationTypeDefinition() {\n      var start = this._lexer.token;\n      var operation = this.parseOperationType();\n      this.expectToken(TokenKind.COLON);\n      var type = this.parseNamedType();\n      return this.node(start, {\n        kind: Kind.OPERATION_TYPE_DEFINITION,\n        operation: operation,\n        type: type\n      });\n    }\n    /**\r\n     * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\r\n     */\n  }, {\n    key: \"parseScalarTypeDefinition\",\n    value: function parseScalarTypeDefinition() {\n      var start = this._lexer.token;\n      var description = this.parseDescription();\n      this.expectKeyword('scalar');\n      var name = this.parseName();\n      var directives = this.parseConstDirectives();\n      return this.node(start, {\n        kind: Kind.SCALAR_TYPE_DEFINITION,\n        description: description,\n        name: name,\n        directives: directives\n      });\n    }\n    /**\r\n     * ObjectTypeDefinition :\r\n     *   Description?\r\n     *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\r\n     */\n  }, {\n    key: \"parseObjectTypeDefinition\",\n    value: function parseObjectTypeDefinition() {\n      var start = this._lexer.token;\n      var description = this.parseDescription();\n      this.expectKeyword('type');\n      var name = this.parseName();\n      var interfaces = this.parseImplementsInterfaces();\n      var directives = this.parseConstDirectives();\n      var fields = this.parseFieldsDefinition();\n      return this.node(start, {\n        kind: Kind.OBJECT_TYPE_DEFINITION,\n        description: description,\n        name: name,\n        interfaces: interfaces,\n        directives: directives,\n        fields: fields\n      });\n    }\n    /**\r\n     * ImplementsInterfaces :\r\n     *   - implements `&`? NamedType\r\n     *   - ImplementsInterfaces & NamedType\r\n     */\n  }, {\n    key: \"parseImplementsInterfaces\",\n    value: function parseImplementsInterfaces() {\n      return this.expectOptionalKeyword('implements') ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];\n    }\n    /**\r\n     * ```\r\n     * FieldsDefinition : { FieldDefinition+ }\r\n     * ```\r\n     */\n  }, {\n    key: \"parseFieldsDefinition\",\n    value: function parseFieldsDefinition() {\n      return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);\n    }\n    /**\r\n     * FieldDefinition :\r\n     *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\r\n     */\n  }, {\n    key: \"parseFieldDefinition\",\n    value: function parseFieldDefinition() {\n      var start = this._lexer.token;\n      var description = this.parseDescription();\n      var name = this.parseName();\n      var args = this.parseArgumentDefs();\n      this.expectToken(TokenKind.COLON);\n      var type = this.parseTypeReference();\n      var directives = this.parseConstDirectives();\n      return this.node(start, {\n        kind: Kind.FIELD_DEFINITION,\n        description: description,\n        name: name,\n        arguments: args,\n        type: type,\n        directives: directives\n      });\n    }\n    /**\r\n     * ArgumentsDefinition : ( InputValueDefinition+ )\r\n     */\n  }, {\n    key: \"parseArgumentDefs\",\n    value: function parseArgumentDefs() {\n      return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);\n    }\n    /**\r\n     * InputValueDefinition :\r\n     *   - Description? Name : Type DefaultValue? Directives[Const]?\r\n     */\n  }, {\n    key: \"parseInputValueDef\",\n    value: function parseInputValueDef() {\n      var start = this._lexer.token;\n      var description = this.parseDescription();\n      var name = this.parseName();\n      this.expectToken(TokenKind.COLON);\n      var type = this.parseTypeReference();\n      var defaultValue;\n      if (this.expectOptionalToken(TokenKind.EQUALS)) {\n        defaultValue = this.parseConstValueLiteral();\n      }\n      var directives = this.parseConstDirectives();\n      return this.node(start, {\n        kind: Kind.INPUT_VALUE_DEFINITION,\n        description: description,\n        name: name,\n        type: type,\n        defaultValue: defaultValue,\n        directives: directives\n      });\n    }\n    /**\r\n     * InterfaceTypeDefinition :\r\n     *   - Description? interface Name Directives[Const]? FieldsDefinition?\r\n     */\n  }, {\n    key: \"parseInterfaceTypeDefinition\",\n    value: function parseInterfaceTypeDefinition() {\n      var start = this._lexer.token;\n      var description = this.parseDescription();\n      this.expectKeyword('interface');\n      var name = this.parseName();\n      var interfaces = this.parseImplementsInterfaces();\n      var directives = this.parseConstDirectives();\n      var fields = this.parseFieldsDefinition();\n      return this.node(start, {\n        kind: Kind.INTERFACE_TYPE_DEFINITION,\n        description: description,\n        name: name,\n        interfaces: interfaces,\n        directives: directives,\n        fields: fields\n      });\n    }\n    /**\r\n     * UnionTypeDefinition :\r\n     *   - Description? union Name Directives[Const]? UnionMemberTypes?\r\n     */\n  }, {\n    key: \"parseUnionTypeDefinition\",\n    value: function parseUnionTypeDefinition() {\n      var start = this._lexer.token;\n      var description = this.parseDescription();\n      this.expectKeyword('union');\n      var name = this.parseName();\n      var directives = this.parseConstDirectives();\n      var types = this.parseUnionMemberTypes();\n      return this.node(start, {\n        kind: Kind.UNION_TYPE_DEFINITION,\n        description: description,\n        name: name,\n        directives: directives,\n        types: types\n      });\n    }\n    /**\r\n     * UnionMemberTypes :\r\n     *   - = `|`? NamedType\r\n     *   - UnionMemberTypes | NamedType\r\n     */\n  }, {\n    key: \"parseUnionMemberTypes\",\n    value: function parseUnionMemberTypes() {\n      return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];\n    }\n    /**\r\n     * EnumTypeDefinition :\r\n     *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\r\n     */\n  }, {\n    key: \"parseEnumTypeDefinition\",\n    value: function parseEnumTypeDefinition() {\n      var start = this._lexer.token;\n      var description = this.parseDescription();\n      this.expectKeyword('enum');\n      var name = this.parseName();\n      var directives = this.parseConstDirectives();\n      var values = this.parseEnumValuesDefinition();\n      return this.node(start, {\n        kind: Kind.ENUM_TYPE_DEFINITION,\n        description: description,\n        name: name,\n        directives: directives,\n        values: values\n      });\n    }\n    /**\r\n     * ```\r\n     * EnumValuesDefinition : { EnumValueDefinition+ }\r\n     * ```\r\n     */\n  }, {\n    key: \"parseEnumValuesDefinition\",\n    value: function parseEnumValuesDefinition() {\n      return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);\n    }\n    /**\r\n     * EnumValueDefinition : Description? EnumValue Directives[Const]?\r\n     */\n  }, {\n    key: \"parseEnumValueDefinition\",\n    value: function parseEnumValueDefinition() {\n      var start = this._lexer.token;\n      var description = this.parseDescription();\n      var name = this.parseEnumValueName();\n      var directives = this.parseConstDirectives();\n      return this.node(start, {\n        kind: Kind.ENUM_VALUE_DEFINITION,\n        description: description,\n        name: name,\n        directives: directives\n      });\n    }\n    /**\r\n     * EnumValue : Name but not `true`, `false` or `null`\r\n     */\n  }, {\n    key: \"parseEnumValueName\",\n    value: function parseEnumValueName() {\n      if (this._lexer.token.value === 'true' || this._lexer.token.value === 'false' || this._lexer.token.value === 'null') {\n        throw syntaxError(this._lexer.source, this._lexer.token.start, \"\".concat(getTokenDesc(this._lexer.token), \" is reserved and cannot be used for an enum value.\"));\n      }\n      return this.parseName();\n    }\n    /**\r\n     * InputObjectTypeDefinition :\r\n     *   - Description? input Name Directives[Const]? InputFieldsDefinition?\r\n     */\n  }, {\n    key: \"parseInputObjectTypeDefinition\",\n    value: function parseInputObjectTypeDefinition() {\n      var start = this._lexer.token;\n      var description = this.parseDescription();\n      this.expectKeyword('input');\n      var name = this.parseName();\n      var directives = this.parseConstDirectives();\n      var fields = this.parseInputFieldsDefinition();\n      return this.node(start, {\n        kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n        description: description,\n        name: name,\n        directives: directives,\n        fields: fields\n      });\n    }\n    /**\r\n     * ```\r\n     * InputFieldsDefinition : { InputValueDefinition+ }\r\n     * ```\r\n     */\n  }, {\n    key: \"parseInputFieldsDefinition\",\n    value: function parseInputFieldsDefinition() {\n      return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);\n    }\n    /**\r\n     * TypeSystemExtension :\r\n     *   - SchemaExtension\r\n     *   - TypeExtension\r\n     *\r\n     * TypeExtension :\r\n     *   - ScalarTypeExtension\r\n     *   - ObjectTypeExtension\r\n     *   - InterfaceTypeExtension\r\n     *   - UnionTypeExtension\r\n     *   - EnumTypeExtension\r\n     *   - InputObjectTypeDefinition\r\n     */\n  }, {\n    key: \"parseTypeSystemExtension\",\n    value: function parseTypeSystemExtension() {\n      var keywordToken = this._lexer.lookahead();\n      if (keywordToken.kind === TokenKind.NAME) {\n        switch (keywordToken.value) {\n          case 'schema':\n            return this.parseSchemaExtension();\n          case 'scalar':\n            return this.parseScalarTypeExtension();\n          case 'type':\n            return this.parseObjectTypeExtension();\n          case 'interface':\n            return this.parseInterfaceTypeExtension();\n          case 'union':\n            return this.parseUnionTypeExtension();\n          case 'enum':\n            return this.parseEnumTypeExtension();\n          case 'input':\n            return this.parseInputObjectTypeExtension();\n        }\n      }\n      throw this.unexpected(keywordToken);\n    }\n    /**\r\n     * ```\r\n     * SchemaExtension :\r\n     *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\r\n     *  - extend schema Directives[Const]\r\n     * ```\r\n     */\n  }, {\n    key: \"parseSchemaExtension\",\n    value: function parseSchemaExtension() {\n      var start = this._lexer.token;\n      this.expectKeyword('extend');\n      this.expectKeyword('schema');\n      var directives = this.parseConstDirectives();\n      var operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n      if (directives.length === 0 && operationTypes.length === 0) {\n        throw this.unexpected();\n      }\n      return this.node(start, {\n        kind: Kind.SCHEMA_EXTENSION,\n        directives: directives,\n        operationTypes: operationTypes\n      });\n    }\n    /**\r\n     * ScalarTypeExtension :\r\n     *   - extend scalar Name Directives[Const]\r\n     */\n  }, {\n    key: \"parseScalarTypeExtension\",\n    value: function parseScalarTypeExtension() {\n      var start = this._lexer.token;\n      this.expectKeyword('extend');\n      this.expectKeyword('scalar');\n      var name = this.parseName();\n      var directives = this.parseConstDirectives();\n      if (directives.length === 0) {\n        throw this.unexpected();\n      }\n      return this.node(start, {\n        kind: Kind.SCALAR_TYPE_EXTENSION,\n        name: name,\n        directives: directives\n      });\n    }\n    /**\r\n     * ObjectTypeExtension :\r\n     *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\r\n     *  - extend type Name ImplementsInterfaces? Directives[Const]\r\n     *  - extend type Name ImplementsInterfaces\r\n     */\n  }, {\n    key: \"parseObjectTypeExtension\",\n    value: function parseObjectTypeExtension() {\n      var start = this._lexer.token;\n      this.expectKeyword('extend');\n      this.expectKeyword('type');\n      var name = this.parseName();\n      var interfaces = this.parseImplementsInterfaces();\n      var directives = this.parseConstDirectives();\n      var fields = this.parseFieldsDefinition();\n      if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n        throw this.unexpected();\n      }\n      return this.node(start, {\n        kind: Kind.OBJECT_TYPE_EXTENSION,\n        name: name,\n        interfaces: interfaces,\n        directives: directives,\n        fields: fields\n      });\n    }\n    /**\r\n     * InterfaceTypeExtension :\r\n     *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\r\n     *  - extend interface Name ImplementsInterfaces? Directives[Const]\r\n     *  - extend interface Name ImplementsInterfaces\r\n     */\n  }, {\n    key: \"parseInterfaceTypeExtension\",\n    value: function parseInterfaceTypeExtension() {\n      var start = this._lexer.token;\n      this.expectKeyword('extend');\n      this.expectKeyword('interface');\n      var name = this.parseName();\n      var interfaces = this.parseImplementsInterfaces();\n      var directives = this.parseConstDirectives();\n      var fields = this.parseFieldsDefinition();\n      if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n        throw this.unexpected();\n      }\n      return this.node(start, {\n        kind: Kind.INTERFACE_TYPE_EXTENSION,\n        name: name,\n        interfaces: interfaces,\n        directives: directives,\n        fields: fields\n      });\n    }\n    /**\r\n     * UnionTypeExtension :\r\n     *   - extend union Name Directives[Const]? UnionMemberTypes\r\n     *   - extend union Name Directives[Const]\r\n     */\n  }, {\n    key: \"parseUnionTypeExtension\",\n    value: function parseUnionTypeExtension() {\n      var start = this._lexer.token;\n      this.expectKeyword('extend');\n      this.expectKeyword('union');\n      var name = this.parseName();\n      var directives = this.parseConstDirectives();\n      var types = this.parseUnionMemberTypes();\n      if (directives.length === 0 && types.length === 0) {\n        throw this.unexpected();\n      }\n      return this.node(start, {\n        kind: Kind.UNION_TYPE_EXTENSION,\n        name: name,\n        directives: directives,\n        types: types\n      });\n    }\n    /**\r\n     * EnumTypeExtension :\r\n     *   - extend enum Name Directives[Const]? EnumValuesDefinition\r\n     *   - extend enum Name Directives[Const]\r\n     */\n  }, {\n    key: \"parseEnumTypeExtension\",\n    value: function parseEnumTypeExtension() {\n      var start = this._lexer.token;\n      this.expectKeyword('extend');\n      this.expectKeyword('enum');\n      var name = this.parseName();\n      var directives = this.parseConstDirectives();\n      var values = this.parseEnumValuesDefinition();\n      if (directives.length === 0 && values.length === 0) {\n        throw this.unexpected();\n      }\n      return this.node(start, {\n        kind: Kind.ENUM_TYPE_EXTENSION,\n        name: name,\n        directives: directives,\n        values: values\n      });\n    }\n    /**\r\n     * InputObjectTypeExtension :\r\n     *   - extend input Name Directives[Const]? InputFieldsDefinition\r\n     *   - extend input Name Directives[Const]\r\n     */\n  }, {\n    key: \"parseInputObjectTypeExtension\",\n    value: function parseInputObjectTypeExtension() {\n      var start = this._lexer.token;\n      this.expectKeyword('extend');\n      this.expectKeyword('input');\n      var name = this.parseName();\n      var directives = this.parseConstDirectives();\n      var fields = this.parseInputFieldsDefinition();\n      if (directives.length === 0 && fields.length === 0) {\n        throw this.unexpected();\n      }\n      return this.node(start, {\n        kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n        name: name,\n        directives: directives,\n        fields: fields\n      });\n    }\n    /**\r\n     * ```\r\n     * DirectiveDefinition :\r\n     *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\r\n     * ```\r\n     */\n  }, {\n    key: \"parseDirectiveDefinition\",\n    value: function parseDirectiveDefinition() {\n      var start = this._lexer.token;\n      var description = this.parseDescription();\n      this.expectKeyword('directive');\n      this.expectToken(TokenKind.AT);\n      var name = this.parseName();\n      var args = this.parseArgumentDefs();\n      var repeatable = this.expectOptionalKeyword('repeatable');\n      this.expectKeyword('on');\n      var locations = this.parseDirectiveLocations();\n      return this.node(start, {\n        kind: Kind.DIRECTIVE_DEFINITION,\n        description: description,\n        name: name,\n        arguments: args,\n        repeatable: repeatable,\n        locations: locations\n      });\n    }\n    /**\r\n     * DirectiveLocations :\r\n     *   - `|`? DirectiveLocation\r\n     *   - DirectiveLocations | DirectiveLocation\r\n     */\n  }, {\n    key: \"parseDirectiveLocations\",\n    value: function parseDirectiveLocations() {\n      return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);\n    }\n    /*\r\n     * DirectiveLocation :\r\n     *   - ExecutableDirectiveLocation\r\n     *   - TypeSystemDirectiveLocation\r\n     *\r\n     * ExecutableDirectiveLocation : one of\r\n     *   `QUERY`\r\n     *   `MUTATION`\r\n     *   `SUBSCRIPTION`\r\n     *   `FIELD`\r\n     *   `FRAGMENT_DEFINITION`\r\n     *   `FRAGMENT_SPREAD`\r\n     *   `INLINE_FRAGMENT`\r\n     *\r\n     * TypeSystemDirectiveLocation : one of\r\n     *   `SCHEMA`\r\n     *   `SCALAR`\r\n     *   `OBJECT`\r\n     *   `FIELD_DEFINITION`\r\n     *   `ARGUMENT_DEFINITION`\r\n     *   `INTERFACE`\r\n     *   `UNION`\r\n     *   `ENUM`\r\n     *   `ENUM_VALUE`\r\n     *   `INPUT_OBJECT`\r\n     *   `INPUT_FIELD_DEFINITION`\r\n     */\n  }, {\n    key: \"parseDirectiveLocation\",\n    value: function parseDirectiveLocation() {\n      var start = this._lexer.token;\n      var name = this.parseName();\n      if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {\n        return name;\n      }\n      throw this.unexpected(start);\n    } // Core parsing utility functions\n\n    /**\r\n     * Returns a node that, if configured to do so, sets a \"loc\" field as a\r\n     * location object, used to identify the place in the source that created a\r\n     * given parsed object.\r\n     */\n  }, {\n    key: \"node\",\n    value: function node(startToken, _node) {\n      if (this._options.noLocation !== true) {\n        _node.loc = new Location(startToken, this._lexer.lastToken, this._lexer.source);\n      }\n      return _node;\n    }\n    /**\r\n     * Determines if the next token is of a given kind\r\n     */\n  }, {\n    key: \"peek\",\n    value: function peek(kind) {\n      return this._lexer.token.kind === kind;\n    }\n    /**\r\n     * If the next token is of the given kind, return that token after advancing the lexer.\r\n     * Otherwise, do not change the parser state and throw an error.\r\n     */\n  }, {\n    key: \"expectToken\",\n    value: function expectToken(kind) {\n      var token = this._lexer.token;\n      if (token.kind === kind) {\n        this.advanceLexer();\n        return token;\n      }\n      throw syntaxError(this._lexer.source, token.start, \"Expected \".concat(getTokenKindDesc(kind), \", found \").concat(getTokenDesc(token), \".\"));\n    }\n    /**\r\n     * If the next token is of the given kind, return \"true\" after advancing the lexer.\r\n     * Otherwise, do not change the parser state and return \"false\".\r\n     */\n  }, {\n    key: \"expectOptionalToken\",\n    value: function expectOptionalToken(kind) {\n      var token = this._lexer.token;\n      if (token.kind === kind) {\n        this.advanceLexer();\n        return true;\n      }\n      return false;\n    }\n    /**\r\n     * If the next token is a given keyword, advance the lexer.\r\n     * Otherwise, do not change the parser state and throw an error.\r\n     */\n  }, {\n    key: \"expectKeyword\",\n    value: function expectKeyword(value) {\n      var token = this._lexer.token;\n      if (token.kind === TokenKind.NAME && token.value === value) {\n        this.advanceLexer();\n      } else {\n        throw syntaxError(this._lexer.source, token.start, \"Expected \\\"\".concat(value, \"\\\", found \").concat(getTokenDesc(token), \".\"));\n      }\n    }\n    /**\r\n     * If the next token is a given keyword, return \"true\" after advancing the lexer.\r\n     * Otherwise, do not change the parser state and return \"false\".\r\n     */\n  }, {\n    key: \"expectOptionalKeyword\",\n    value: function expectOptionalKeyword(value) {\n      var token = this._lexer.token;\n      if (token.kind === TokenKind.NAME && token.value === value) {\n        this.advanceLexer();\n        return true;\n      }\n      return false;\n    }\n    /**\r\n     * Helper function for creating an error when an unexpected lexed token is encountered.\r\n     */\n  }, {\n    key: \"unexpected\",\n    value: function unexpected(atToken) {\n      var token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\n      return syntaxError(this._lexer.source, token.start, \"Unexpected \".concat(getTokenDesc(token), \".\"));\n    }\n    /**\r\n     * Returns a possibly empty list of parse nodes, determined by the parseFn.\r\n     * This list begins with a lex token of openKind and ends with a lex token of closeKind.\r\n     * Advances the parser to the next lex token after the closing token.\r\n     */\n  }, {\n    key: \"any\",\n    value: function any(openKind, parseFn, closeKind) {\n      this.expectToken(openKind);\n      var nodes = [];\n      while (!this.expectOptionalToken(closeKind)) {\n        nodes.push(parseFn.call(this));\n      }\n      return nodes;\n    }\n    /**\r\n     * Returns a list of parse nodes, determined by the parseFn.\r\n     * It can be empty only if open token is missing otherwise it will always return non-empty list\r\n     * that begins with a lex token of openKind and ends with a lex token of closeKind.\r\n     * Advances the parser to the next lex token after the closing token.\r\n     */\n  }, {\n    key: \"optionalMany\",\n    value: function optionalMany(openKind, parseFn, closeKind) {\n      if (this.expectOptionalToken(openKind)) {\n        var nodes = [];\n        do {\n          nodes.push(parseFn.call(this));\n        } while (!this.expectOptionalToken(closeKind));\n        return nodes;\n      }\n      return [];\n    }\n    /**\r\n     * Returns a non-empty list of parse nodes, determined by the parseFn.\r\n     * This list begins with a lex token of openKind and ends with a lex token of closeKind.\r\n     * Advances the parser to the next lex token after the closing token.\r\n     */\n  }, {\n    key: \"many\",\n    value: function many(openKind, parseFn, closeKind) {\n      this.expectToken(openKind);\n      var nodes = [];\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n      return nodes;\n    }\n    /**\r\n     * Returns a non-empty list of parse nodes, determined by the parseFn.\r\n     * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.\r\n     * Advances the parser to the next lex token after last item in the list.\r\n     */\n  }, {\n    key: \"delimitedMany\",\n    value: function delimitedMany(delimiterKind, parseFn) {\n      this.expectOptionalToken(delimiterKind);\n      var nodes = [];\n      do {\n        nodes.push(parseFn.call(this));\n      } while (this.expectOptionalToken(delimiterKind));\n      return nodes;\n    }\n  }, {\n    key: \"advanceLexer\",\n    value: function advanceLexer() {\n      var maxTokens = this._options.maxTokens;\n      var token = this._lexer.advance();\n      if (maxTokens !== undefined && token.kind !== TokenKind.EOF) {\n        ++this._tokenCounter;\n        if (this._tokenCounter > maxTokens) {\n          throw syntaxError(this._lexer.source, token.start, \"Document contains more that \".concat(maxTokens, \" tokens. Parsing aborted.\"));\n        }\n      }\n    }\n  }]);\n  return Parser;\n}();\n/**\r\n * A helper function to describe a token as a string for debugging.\r\n */\n\nfunction getTokenDesc(token) {\n  var value = token.value;\n  return getTokenKindDesc(token.kind) + (value != null ? \" \\\"\".concat(value, \"\\\"\") : '');\n}\n/**\r\n * A helper function to describe a token kind as a string for debugging.\r\n */\n\nfunction getTokenKindDesc(kind) {\n  return isPunctuatorTokenKind(kind) ? \"\\\"\".concat(kind, \"\\\"\") : kind;\n}","map":{"version":3,"names":["syntaxError","Location","OperationTypeNode","DirectiveLocation","Kind","isPunctuatorTokenKind","Lexer","isSource","Source","TokenKind","parse","source","options","parser","Parser","parseDocument","parseValue","expectToken","SOF","value","parseValueLiteral","EOF","parseConstValue","parseConstValueLiteral","parseType","type","parseTypeReference","arguments","length","undefined","_classCallCheck","sourceObj","_lexer","_options","_tokenCounter","_createClass","key","parseName","token","NAME","node","kind","DOCUMENT","definitions","many","parseDefinition","peek","BRACE_L","parseOperationDefinition","hasDescription","peekDescription","keywordToken","lookahead","parseSchemaDefinition","parseScalarTypeDefinition","parseObjectTypeDefinition","parseInterfaceTypeDefinition","parseUnionTypeDefinition","parseEnumTypeDefinition","parseInputObjectTypeDefinition","parseDirectiveDefinition","start","parseFragmentDefinition","parseTypeSystemExtension","unexpected","OPERATION_DEFINITION","operation","QUERY","name","variableDefinitions","directives","selectionSet","parseSelectionSet","parseOperationType","parseVariableDefinitions","parseDirectives","operationToken","MUTATION","SUBSCRIPTION","optionalMany","PAREN_L","parseVariableDefinition","PAREN_R","VARIABLE_DEFINITION","variable","parseVariable","COLON","defaultValue","expectOptionalToken","EQUALS","parseConstDirectives","DOLLAR","VARIABLE","SELECTION_SET","selections","parseSelection","BRACE_R","SPREAD","parseFragment","parseField","nameOrAlias","alias","FIELD","parseArguments","isConst","item","parseConstArgument","parseArgument","ARGUMENT","hasTypeCondition","expectOptionalKeyword","FRAGMENT_SPREAD","parseFragmentName","INLINE_FRAGMENT","typeCondition","parseNamedType","expectKeyword","allowLegacyFragmentVariables","FRAGMENT_DEFINITION","BRACKET_L","parseList","parseObject","INT","advanceLexer","FLOAT","STRING","BLOCK_STRING","parseStringLiteral","BOOLEAN","NULL","ENUM","varName","concat","block","_this","LIST","values","any","BRACKET_R","_this2","parseObjectField","OBJECT","fields","OBJECT_FIELD","AT","push","parseDirective","DIRECTIVE","innerType","LIST_TYPE","BANG","NON_NULL_TYPE","NAMED_TYPE","parseDescription","description","operationTypes","parseOperationTypeDefinition","SCHEMA_DEFINITION","OPERATION_TYPE_DEFINITION","SCALAR_TYPE_DEFINITION","interfaces","parseImplementsInterfaces","parseFieldsDefinition","OBJECT_TYPE_DEFINITION","delimitedMany","AMP","parseFieldDefinition","args","parseArgumentDefs","FIELD_DEFINITION","parseInputValueDef","INPUT_VALUE_DEFINITION","INTERFACE_TYPE_DEFINITION","types","parseUnionMemberTypes","UNION_TYPE_DEFINITION","PIPE","parseEnumValuesDefinition","ENUM_TYPE_DEFINITION","parseEnumValueDefinition","parseEnumValueName","ENUM_VALUE_DEFINITION","getTokenDesc","parseInputFieldsDefinition","INPUT_OBJECT_TYPE_DEFINITION","parseSchemaExtension","parseScalarTypeExtension","parseObjectTypeExtension","parseInterfaceTypeExtension","parseUnionTypeExtension","parseEnumTypeExtension","parseInputObjectTypeExtension","SCHEMA_EXTENSION","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","repeatable","locations","parseDirectiveLocations","DIRECTIVE_DEFINITION","parseDirectiveLocation","Object","prototype","hasOwnProperty","call","startToken","noLocation","loc","lastToken","getTokenKindDesc","atToken","openKind","parseFn","closeKind","nodes","delimiterKind","maxTokens","advance"],"sources":["C:/Users/jared/PortfolioProjects/BookwormSE/Develop/client/node_modules/graphql/language/parser.mjs"],"sourcesContent":["import { syntaxError } from '../error/syntaxError.mjs';\r\nimport { Location, OperationTypeNode } from './ast.mjs';\r\nimport { DirectiveLocation } from './directiveLocation.mjs';\r\nimport { Kind } from './kinds.mjs';\r\nimport { isPunctuatorTokenKind, Lexer } from './lexer.mjs';\r\nimport { isSource, Source } from './source.mjs';\r\nimport { TokenKind } from './tokenKind.mjs';\r\n/**\r\n * Configuration options to control parser behavior\r\n */\r\n\r\n/**\r\n * Given a GraphQL source, parses it into a Document.\r\n * Throws GraphQLError if a syntax error is encountered.\r\n */\r\nexport function parse(source, options) {\r\n  const parser = new Parser(source, options);\r\n  return parser.parseDocument();\r\n}\r\n/**\r\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\r\n * that value.\r\n * Throws GraphQLError if a syntax error is encountered.\r\n *\r\n * This is useful within tools that operate upon GraphQL Values directly and\r\n * in isolation of complete GraphQL documents.\r\n *\r\n * Consider providing the results to the utility function: valueFromAST().\r\n */\r\n\r\nexport function parseValue(source, options) {\r\n  const parser = new Parser(source, options);\r\n  parser.expectToken(TokenKind.SOF);\r\n  const value = parser.parseValueLiteral(false);\r\n  parser.expectToken(TokenKind.EOF);\r\n  return value;\r\n}\r\n/**\r\n * Similar to parseValue(), but raises a parse error if it encounters a\r\n * variable. The return type will be a constant value.\r\n */\r\n\r\nexport function parseConstValue(source, options) {\r\n  const parser = new Parser(source, options);\r\n  parser.expectToken(TokenKind.SOF);\r\n  const value = parser.parseConstValueLiteral();\r\n  parser.expectToken(TokenKind.EOF);\r\n  return value;\r\n}\r\n/**\r\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\r\n * that type.\r\n * Throws GraphQLError if a syntax error is encountered.\r\n *\r\n * This is useful within tools that operate upon GraphQL Types directly and\r\n * in isolation of complete GraphQL documents.\r\n *\r\n * Consider providing the results to the utility function: typeFromAST().\r\n */\r\n\r\nexport function parseType(source, options) {\r\n  const parser = new Parser(source, options);\r\n  parser.expectToken(TokenKind.SOF);\r\n  const type = parser.parseTypeReference();\r\n  parser.expectToken(TokenKind.EOF);\r\n  return type;\r\n}\r\n/**\r\n * This class is exported only to assist people in implementing their own parsers\r\n * without duplicating too much code and should be used only as last resort for cases\r\n * such as experimental syntax or if certain features could not be contributed upstream.\r\n *\r\n * It is still part of the internal API and is versioned, so any changes to it are never\r\n * considered breaking changes. If you still need to support multiple versions of the\r\n * library, please use the `versionInfo` variable for version detection.\r\n *\r\n * @internal\r\n */\r\n\r\nexport class Parser {\r\n  constructor(source, options = {}) {\r\n    const sourceObj = isSource(source) ? source : new Source(source);\r\n    this._lexer = new Lexer(sourceObj);\r\n    this._options = options;\r\n    this._tokenCounter = 0;\r\n  }\r\n  /**\r\n   * Converts a name lex token into a name parse node.\r\n   */\r\n\r\n  parseName() {\r\n    const token = this.expectToken(TokenKind.NAME);\r\n    return this.node(token, {\r\n      kind: Kind.NAME,\r\n      value: token.value,\r\n    });\r\n  } // Implements the parsing rules in the Document section.\r\n\r\n  /**\r\n   * Document : Definition+\r\n   */\r\n\r\n  parseDocument() {\r\n    return this.node(this._lexer.token, {\r\n      kind: Kind.DOCUMENT,\r\n      definitions: this.many(\r\n        TokenKind.SOF,\r\n        this.parseDefinition,\r\n        TokenKind.EOF,\r\n      ),\r\n    });\r\n  }\r\n  /**\r\n   * Definition :\r\n   *   - ExecutableDefinition\r\n   *   - TypeSystemDefinition\r\n   *   - TypeSystemExtension\r\n   *\r\n   * ExecutableDefinition :\r\n   *   - OperationDefinition\r\n   *   - FragmentDefinition\r\n   *\r\n   * TypeSystemDefinition :\r\n   *   - SchemaDefinition\r\n   *   - TypeDefinition\r\n   *   - DirectiveDefinition\r\n   *\r\n   * TypeDefinition :\r\n   *   - ScalarTypeDefinition\r\n   *   - ObjectTypeDefinition\r\n   *   - InterfaceTypeDefinition\r\n   *   - UnionTypeDefinition\r\n   *   - EnumTypeDefinition\r\n   *   - InputObjectTypeDefinition\r\n   */\r\n\r\n  parseDefinition() {\r\n    if (this.peek(TokenKind.BRACE_L)) {\r\n      return this.parseOperationDefinition();\r\n    } // Many definitions begin with a description and require a lookahead.\r\n\r\n    const hasDescription = this.peekDescription();\r\n    const keywordToken = hasDescription\r\n      ? this._lexer.lookahead()\r\n      : this._lexer.token;\r\n\r\n    if (keywordToken.kind === TokenKind.NAME) {\r\n      switch (keywordToken.value) {\r\n        case 'schema':\r\n          return this.parseSchemaDefinition();\r\n\r\n        case 'scalar':\r\n          return this.parseScalarTypeDefinition();\r\n\r\n        case 'type':\r\n          return this.parseObjectTypeDefinition();\r\n\r\n        case 'interface':\r\n          return this.parseInterfaceTypeDefinition();\r\n\r\n        case 'union':\r\n          return this.parseUnionTypeDefinition();\r\n\r\n        case 'enum':\r\n          return this.parseEnumTypeDefinition();\r\n\r\n        case 'input':\r\n          return this.parseInputObjectTypeDefinition();\r\n\r\n        case 'directive':\r\n          return this.parseDirectiveDefinition();\r\n      }\r\n\r\n      if (hasDescription) {\r\n        throw syntaxError(\r\n          this._lexer.source,\r\n          this._lexer.token.start,\r\n          'Unexpected description, descriptions are supported only on type definitions.',\r\n        );\r\n      }\r\n\r\n      switch (keywordToken.value) {\r\n        case 'query':\r\n        case 'mutation':\r\n        case 'subscription':\r\n          return this.parseOperationDefinition();\r\n\r\n        case 'fragment':\r\n          return this.parseFragmentDefinition();\r\n\r\n        case 'extend':\r\n          return this.parseTypeSystemExtension();\r\n      }\r\n    }\r\n\r\n    throw this.unexpected(keywordToken);\r\n  } // Implements the parsing rules in the Operations section.\r\n\r\n  /**\r\n   * OperationDefinition :\r\n   *  - SelectionSet\r\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\r\n   */\r\n\r\n  parseOperationDefinition() {\r\n    const start = this._lexer.token;\r\n\r\n    if (this.peek(TokenKind.BRACE_L)) {\r\n      return this.node(start, {\r\n        kind: Kind.OPERATION_DEFINITION,\r\n        operation: OperationTypeNode.QUERY,\r\n        name: undefined,\r\n        variableDefinitions: [],\r\n        directives: [],\r\n        selectionSet: this.parseSelectionSet(),\r\n      });\r\n    }\r\n\r\n    const operation = this.parseOperationType();\r\n    let name;\r\n\r\n    if (this.peek(TokenKind.NAME)) {\r\n      name = this.parseName();\r\n    }\r\n\r\n    return this.node(start, {\r\n      kind: Kind.OPERATION_DEFINITION,\r\n      operation,\r\n      name,\r\n      variableDefinitions: this.parseVariableDefinitions(),\r\n      directives: this.parseDirectives(false),\r\n      selectionSet: this.parseSelectionSet(),\r\n    });\r\n  }\r\n  /**\r\n   * OperationType : one of query mutation subscription\r\n   */\r\n\r\n  parseOperationType() {\r\n    const operationToken = this.expectToken(TokenKind.NAME);\r\n\r\n    switch (operationToken.value) {\r\n      case 'query':\r\n        return OperationTypeNode.QUERY;\r\n\r\n      case 'mutation':\r\n        return OperationTypeNode.MUTATION;\r\n\r\n      case 'subscription':\r\n        return OperationTypeNode.SUBSCRIPTION;\r\n    }\r\n\r\n    throw this.unexpected(operationToken);\r\n  }\r\n  /**\r\n   * VariableDefinitions : ( VariableDefinition+ )\r\n   */\r\n\r\n  parseVariableDefinitions() {\r\n    return this.optionalMany(\r\n      TokenKind.PAREN_L,\r\n      this.parseVariableDefinition,\r\n      TokenKind.PAREN_R,\r\n    );\r\n  }\r\n  /**\r\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\r\n   */\r\n\r\n  parseVariableDefinition() {\r\n    return this.node(this._lexer.token, {\r\n      kind: Kind.VARIABLE_DEFINITION,\r\n      variable: this.parseVariable(),\r\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\r\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS)\r\n        ? this.parseConstValueLiteral()\r\n        : undefined,\r\n      directives: this.parseConstDirectives(),\r\n    });\r\n  }\r\n  /**\r\n   * Variable : $ Name\r\n   */\r\n\r\n  parseVariable() {\r\n    const start = this._lexer.token;\r\n    this.expectToken(TokenKind.DOLLAR);\r\n    return this.node(start, {\r\n      kind: Kind.VARIABLE,\r\n      name: this.parseName(),\r\n    });\r\n  }\r\n  /**\r\n   * ```\r\n   * SelectionSet : { Selection+ }\r\n   * ```\r\n   */\r\n\r\n  parseSelectionSet() {\r\n    return this.node(this._lexer.token, {\r\n      kind: Kind.SELECTION_SET,\r\n      selections: this.many(\r\n        TokenKind.BRACE_L,\r\n        this.parseSelection,\r\n        TokenKind.BRACE_R,\r\n      ),\r\n    });\r\n  }\r\n  /**\r\n   * Selection :\r\n   *   - Field\r\n   *   - FragmentSpread\r\n   *   - InlineFragment\r\n   */\r\n\r\n  parseSelection() {\r\n    return this.peek(TokenKind.SPREAD)\r\n      ? this.parseFragment()\r\n      : this.parseField();\r\n  }\r\n  /**\r\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\r\n   *\r\n   * Alias : Name :\r\n   */\r\n\r\n  parseField() {\r\n    const start = this._lexer.token;\r\n    const nameOrAlias = this.parseName();\r\n    let alias;\r\n    let name;\r\n\r\n    if (this.expectOptionalToken(TokenKind.COLON)) {\r\n      alias = nameOrAlias;\r\n      name = this.parseName();\r\n    } else {\r\n      name = nameOrAlias;\r\n    }\r\n\r\n    return this.node(start, {\r\n      kind: Kind.FIELD,\r\n      alias,\r\n      name,\r\n      arguments: this.parseArguments(false),\r\n      directives: this.parseDirectives(false),\r\n      selectionSet: this.peek(TokenKind.BRACE_L)\r\n        ? this.parseSelectionSet()\r\n        : undefined,\r\n    });\r\n  }\r\n  /**\r\n   * Arguments[Const] : ( Argument[?Const]+ )\r\n   */\r\n\r\n  parseArguments(isConst) {\r\n    const item = isConst ? this.parseConstArgument : this.parseArgument;\r\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\r\n  }\r\n  /**\r\n   * Argument[Const] : Name : Value[?Const]\r\n   */\r\n\r\n  parseArgument(isConst = false) {\r\n    const start = this._lexer.token;\r\n    const name = this.parseName();\r\n    this.expectToken(TokenKind.COLON);\r\n    return this.node(start, {\r\n      kind: Kind.ARGUMENT,\r\n      name,\r\n      value: this.parseValueLiteral(isConst),\r\n    });\r\n  }\r\n\r\n  parseConstArgument() {\r\n    return this.parseArgument(true);\r\n  } // Implements the parsing rules in the Fragments section.\r\n\r\n  /**\r\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\r\n   *\r\n   * FragmentSpread : ... FragmentName Directives?\r\n   *\r\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\r\n   */\r\n\r\n  parseFragment() {\r\n    const start = this._lexer.token;\r\n    this.expectToken(TokenKind.SPREAD);\r\n    const hasTypeCondition = this.expectOptionalKeyword('on');\r\n\r\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\r\n      return this.node(start, {\r\n        kind: Kind.FRAGMENT_SPREAD,\r\n        name: this.parseFragmentName(),\r\n        directives: this.parseDirectives(false),\r\n      });\r\n    }\r\n\r\n    return this.node(start, {\r\n      kind: Kind.INLINE_FRAGMENT,\r\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\r\n      directives: this.parseDirectives(false),\r\n      selectionSet: this.parseSelectionSet(),\r\n    });\r\n  }\r\n  /**\r\n   * FragmentDefinition :\r\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\r\n   *\r\n   * TypeCondition : NamedType\r\n   */\r\n\r\n  parseFragmentDefinition() {\r\n    const start = this._lexer.token;\r\n    this.expectKeyword('fragment'); // Legacy support for defining variables within fragments changes\r\n    // the grammar of FragmentDefinition:\r\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\r\n\r\n    if (this._options.allowLegacyFragmentVariables === true) {\r\n      return this.node(start, {\r\n        kind: Kind.FRAGMENT_DEFINITION,\r\n        name: this.parseFragmentName(),\r\n        variableDefinitions: this.parseVariableDefinitions(),\r\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\r\n        directives: this.parseDirectives(false),\r\n        selectionSet: this.parseSelectionSet(),\r\n      });\r\n    }\r\n\r\n    return this.node(start, {\r\n      kind: Kind.FRAGMENT_DEFINITION,\r\n      name: this.parseFragmentName(),\r\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\r\n      directives: this.parseDirectives(false),\r\n      selectionSet: this.parseSelectionSet(),\r\n    });\r\n  }\r\n  /**\r\n   * FragmentName : Name but not `on`\r\n   */\r\n\r\n  parseFragmentName() {\r\n    if (this._lexer.token.value === 'on') {\r\n      throw this.unexpected();\r\n    }\r\n\r\n    return this.parseName();\r\n  } // Implements the parsing rules in the Values section.\r\n\r\n  /**\r\n   * Value[Const] :\r\n   *   - [~Const] Variable\r\n   *   - IntValue\r\n   *   - FloatValue\r\n   *   - StringValue\r\n   *   - BooleanValue\r\n   *   - NullValue\r\n   *   - EnumValue\r\n   *   - ListValue[?Const]\r\n   *   - ObjectValue[?Const]\r\n   *\r\n   * BooleanValue : one of `true` `false`\r\n   *\r\n   * NullValue : `null`\r\n   *\r\n   * EnumValue : Name but not `true`, `false` or `null`\r\n   */\r\n\r\n  parseValueLiteral(isConst) {\r\n    const token = this._lexer.token;\r\n\r\n    switch (token.kind) {\r\n      case TokenKind.BRACKET_L:\r\n        return this.parseList(isConst);\r\n\r\n      case TokenKind.BRACE_L:\r\n        return this.parseObject(isConst);\r\n\r\n      case TokenKind.INT:\r\n        this.advanceLexer();\r\n        return this.node(token, {\r\n          kind: Kind.INT,\r\n          value: token.value,\r\n        });\r\n\r\n      case TokenKind.FLOAT:\r\n        this.advanceLexer();\r\n        return this.node(token, {\r\n          kind: Kind.FLOAT,\r\n          value: token.value,\r\n        });\r\n\r\n      case TokenKind.STRING:\r\n      case TokenKind.BLOCK_STRING:\r\n        return this.parseStringLiteral();\r\n\r\n      case TokenKind.NAME:\r\n        this.advanceLexer();\r\n\r\n        switch (token.value) {\r\n          case 'true':\r\n            return this.node(token, {\r\n              kind: Kind.BOOLEAN,\r\n              value: true,\r\n            });\r\n\r\n          case 'false':\r\n            return this.node(token, {\r\n              kind: Kind.BOOLEAN,\r\n              value: false,\r\n            });\r\n\r\n          case 'null':\r\n            return this.node(token, {\r\n              kind: Kind.NULL,\r\n            });\r\n\r\n          default:\r\n            return this.node(token, {\r\n              kind: Kind.ENUM,\r\n              value: token.value,\r\n            });\r\n        }\r\n\r\n      case TokenKind.DOLLAR:\r\n        if (isConst) {\r\n          this.expectToken(TokenKind.DOLLAR);\r\n\r\n          if (this._lexer.token.kind === TokenKind.NAME) {\r\n            const varName = this._lexer.token.value;\r\n            throw syntaxError(\r\n              this._lexer.source,\r\n              token.start,\r\n              `Unexpected variable \"$${varName}\" in constant value.`,\r\n            );\r\n          } else {\r\n            throw this.unexpected(token);\r\n          }\r\n        }\r\n\r\n        return this.parseVariable();\r\n\r\n      default:\r\n        throw this.unexpected();\r\n    }\r\n  }\r\n\r\n  parseConstValueLiteral() {\r\n    return this.parseValueLiteral(true);\r\n  }\r\n\r\n  parseStringLiteral() {\r\n    const token = this._lexer.token;\r\n    this.advanceLexer();\r\n    return this.node(token, {\r\n      kind: Kind.STRING,\r\n      value: token.value,\r\n      block: token.kind === TokenKind.BLOCK_STRING,\r\n    });\r\n  }\r\n  /**\r\n   * ListValue[Const] :\r\n   *   - [ ]\r\n   *   - [ Value[?Const]+ ]\r\n   */\r\n\r\n  parseList(isConst) {\r\n    const item = () => this.parseValueLiteral(isConst);\r\n\r\n    return this.node(this._lexer.token, {\r\n      kind: Kind.LIST,\r\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),\r\n    });\r\n  }\r\n  /**\r\n   * ```\r\n   * ObjectValue[Const] :\r\n   *   - { }\r\n   *   - { ObjectField[?Const]+ }\r\n   * ```\r\n   */\r\n\r\n  parseObject(isConst) {\r\n    const item = () => this.parseObjectField(isConst);\r\n\r\n    return this.node(this._lexer.token, {\r\n      kind: Kind.OBJECT,\r\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),\r\n    });\r\n  }\r\n  /**\r\n   * ObjectField[Const] : Name : Value[?Const]\r\n   */\r\n\r\n  parseObjectField(isConst) {\r\n    const start = this._lexer.token;\r\n    const name = this.parseName();\r\n    this.expectToken(TokenKind.COLON);\r\n    return this.node(start, {\r\n      kind: Kind.OBJECT_FIELD,\r\n      name,\r\n      value: this.parseValueLiteral(isConst),\r\n    });\r\n  } // Implements the parsing rules in the Directives section.\r\n\r\n  /**\r\n   * Directives[Const] : Directive[?Const]+\r\n   */\r\n\r\n  parseDirectives(isConst) {\r\n    const directives = [];\r\n\r\n    while (this.peek(TokenKind.AT)) {\r\n      directives.push(this.parseDirective(isConst));\r\n    }\r\n\r\n    return directives;\r\n  }\r\n\r\n  parseConstDirectives() {\r\n    return this.parseDirectives(true);\r\n  }\r\n  /**\r\n   * ```\r\n   * Directive[Const] : @ Name Arguments[?Const]?\r\n   * ```\r\n   */\r\n\r\n  parseDirective(isConst) {\r\n    const start = this._lexer.token;\r\n    this.expectToken(TokenKind.AT);\r\n    return this.node(start, {\r\n      kind: Kind.DIRECTIVE,\r\n      name: this.parseName(),\r\n      arguments: this.parseArguments(isConst),\r\n    });\r\n  } // Implements the parsing rules in the Types section.\r\n\r\n  /**\r\n   * Type :\r\n   *   - NamedType\r\n   *   - ListType\r\n   *   - NonNullType\r\n   */\r\n\r\n  parseTypeReference() {\r\n    const start = this._lexer.token;\r\n    let type;\r\n\r\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\r\n      const innerType = this.parseTypeReference();\r\n      this.expectToken(TokenKind.BRACKET_R);\r\n      type = this.node(start, {\r\n        kind: Kind.LIST_TYPE,\r\n        type: innerType,\r\n      });\r\n    } else {\r\n      type = this.parseNamedType();\r\n    }\r\n\r\n    if (this.expectOptionalToken(TokenKind.BANG)) {\r\n      return this.node(start, {\r\n        kind: Kind.NON_NULL_TYPE,\r\n        type,\r\n      });\r\n    }\r\n\r\n    return type;\r\n  }\r\n  /**\r\n   * NamedType : Name\r\n   */\r\n\r\n  parseNamedType() {\r\n    return this.node(this._lexer.token, {\r\n      kind: Kind.NAMED_TYPE,\r\n      name: this.parseName(),\r\n    });\r\n  } // Implements the parsing rules in the Type Definition section.\r\n\r\n  peekDescription() {\r\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\r\n  }\r\n  /**\r\n   * Description : StringValue\r\n   */\r\n\r\n  parseDescription() {\r\n    if (this.peekDescription()) {\r\n      return this.parseStringLiteral();\r\n    }\r\n  }\r\n  /**\r\n   * ```\r\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\r\n   * ```\r\n   */\r\n\r\n  parseSchemaDefinition() {\r\n    const start = this._lexer.token;\r\n    const description = this.parseDescription();\r\n    this.expectKeyword('schema');\r\n    const directives = this.parseConstDirectives();\r\n    const operationTypes = this.many(\r\n      TokenKind.BRACE_L,\r\n      this.parseOperationTypeDefinition,\r\n      TokenKind.BRACE_R,\r\n    );\r\n    return this.node(start, {\r\n      kind: Kind.SCHEMA_DEFINITION,\r\n      description,\r\n      directives,\r\n      operationTypes,\r\n    });\r\n  }\r\n  /**\r\n   * OperationTypeDefinition : OperationType : NamedType\r\n   */\r\n\r\n  parseOperationTypeDefinition() {\r\n    const start = this._lexer.token;\r\n    const operation = this.parseOperationType();\r\n    this.expectToken(TokenKind.COLON);\r\n    const type = this.parseNamedType();\r\n    return this.node(start, {\r\n      kind: Kind.OPERATION_TYPE_DEFINITION,\r\n      operation,\r\n      type,\r\n    });\r\n  }\r\n  /**\r\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\r\n   */\r\n\r\n  parseScalarTypeDefinition() {\r\n    const start = this._lexer.token;\r\n    const description = this.parseDescription();\r\n    this.expectKeyword('scalar');\r\n    const name = this.parseName();\r\n    const directives = this.parseConstDirectives();\r\n    return this.node(start, {\r\n      kind: Kind.SCALAR_TYPE_DEFINITION,\r\n      description,\r\n      name,\r\n      directives,\r\n    });\r\n  }\r\n  /**\r\n   * ObjectTypeDefinition :\r\n   *   Description?\r\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\r\n   */\r\n\r\n  parseObjectTypeDefinition() {\r\n    const start = this._lexer.token;\r\n    const description = this.parseDescription();\r\n    this.expectKeyword('type');\r\n    const name = this.parseName();\r\n    const interfaces = this.parseImplementsInterfaces();\r\n    const directives = this.parseConstDirectives();\r\n    const fields = this.parseFieldsDefinition();\r\n    return this.node(start, {\r\n      kind: Kind.OBJECT_TYPE_DEFINITION,\r\n      description,\r\n      name,\r\n      interfaces,\r\n      directives,\r\n      fields,\r\n    });\r\n  }\r\n  /**\r\n   * ImplementsInterfaces :\r\n   *   - implements `&`? NamedType\r\n   *   - ImplementsInterfaces & NamedType\r\n   */\r\n\r\n  parseImplementsInterfaces() {\r\n    return this.expectOptionalKeyword('implements')\r\n      ? this.delimitedMany(TokenKind.AMP, this.parseNamedType)\r\n      : [];\r\n  }\r\n  /**\r\n   * ```\r\n   * FieldsDefinition : { FieldDefinition+ }\r\n   * ```\r\n   */\r\n\r\n  parseFieldsDefinition() {\r\n    return this.optionalMany(\r\n      TokenKind.BRACE_L,\r\n      this.parseFieldDefinition,\r\n      TokenKind.BRACE_R,\r\n    );\r\n  }\r\n  /**\r\n   * FieldDefinition :\r\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\r\n   */\r\n\r\n  parseFieldDefinition() {\r\n    const start = this._lexer.token;\r\n    const description = this.parseDescription();\r\n    const name = this.parseName();\r\n    const args = this.parseArgumentDefs();\r\n    this.expectToken(TokenKind.COLON);\r\n    const type = this.parseTypeReference();\r\n    const directives = this.parseConstDirectives();\r\n    return this.node(start, {\r\n      kind: Kind.FIELD_DEFINITION,\r\n      description,\r\n      name,\r\n      arguments: args,\r\n      type,\r\n      directives,\r\n    });\r\n  }\r\n  /**\r\n   * ArgumentsDefinition : ( InputValueDefinition+ )\r\n   */\r\n\r\n  parseArgumentDefs() {\r\n    return this.optionalMany(\r\n      TokenKind.PAREN_L,\r\n      this.parseInputValueDef,\r\n      TokenKind.PAREN_R,\r\n    );\r\n  }\r\n  /**\r\n   * InputValueDefinition :\r\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\r\n   */\r\n\r\n  parseInputValueDef() {\r\n    const start = this._lexer.token;\r\n    const description = this.parseDescription();\r\n    const name = this.parseName();\r\n    this.expectToken(TokenKind.COLON);\r\n    const type = this.parseTypeReference();\r\n    let defaultValue;\r\n\r\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\r\n      defaultValue = this.parseConstValueLiteral();\r\n    }\r\n\r\n    const directives = this.parseConstDirectives();\r\n    return this.node(start, {\r\n      kind: Kind.INPUT_VALUE_DEFINITION,\r\n      description,\r\n      name,\r\n      type,\r\n      defaultValue,\r\n      directives,\r\n    });\r\n  }\r\n  /**\r\n   * InterfaceTypeDefinition :\r\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\r\n   */\r\n\r\n  parseInterfaceTypeDefinition() {\r\n    const start = this._lexer.token;\r\n    const description = this.parseDescription();\r\n    this.expectKeyword('interface');\r\n    const name = this.parseName();\r\n    const interfaces = this.parseImplementsInterfaces();\r\n    const directives = this.parseConstDirectives();\r\n    const fields = this.parseFieldsDefinition();\r\n    return this.node(start, {\r\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\r\n      description,\r\n      name,\r\n      interfaces,\r\n      directives,\r\n      fields,\r\n    });\r\n  }\r\n  /**\r\n   * UnionTypeDefinition :\r\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\r\n   */\r\n\r\n  parseUnionTypeDefinition() {\r\n    const start = this._lexer.token;\r\n    const description = this.parseDescription();\r\n    this.expectKeyword('union');\r\n    const name = this.parseName();\r\n    const directives = this.parseConstDirectives();\r\n    const types = this.parseUnionMemberTypes();\r\n    return this.node(start, {\r\n      kind: Kind.UNION_TYPE_DEFINITION,\r\n      description,\r\n      name,\r\n      directives,\r\n      types,\r\n    });\r\n  }\r\n  /**\r\n   * UnionMemberTypes :\r\n   *   - = `|`? NamedType\r\n   *   - UnionMemberTypes | NamedType\r\n   */\r\n\r\n  parseUnionMemberTypes() {\r\n    return this.expectOptionalToken(TokenKind.EQUALS)\r\n      ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType)\r\n      : [];\r\n  }\r\n  /**\r\n   * EnumTypeDefinition :\r\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\r\n   */\r\n\r\n  parseEnumTypeDefinition() {\r\n    const start = this._lexer.token;\r\n    const description = this.parseDescription();\r\n    this.expectKeyword('enum');\r\n    const name = this.parseName();\r\n    const directives = this.parseConstDirectives();\r\n    const values = this.parseEnumValuesDefinition();\r\n    return this.node(start, {\r\n      kind: Kind.ENUM_TYPE_DEFINITION,\r\n      description,\r\n      name,\r\n      directives,\r\n      values,\r\n    });\r\n  }\r\n  /**\r\n   * ```\r\n   * EnumValuesDefinition : { EnumValueDefinition+ }\r\n   * ```\r\n   */\r\n\r\n  parseEnumValuesDefinition() {\r\n    return this.optionalMany(\r\n      TokenKind.BRACE_L,\r\n      this.parseEnumValueDefinition,\r\n      TokenKind.BRACE_R,\r\n    );\r\n  }\r\n  /**\r\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\r\n   */\r\n\r\n  parseEnumValueDefinition() {\r\n    const start = this._lexer.token;\r\n    const description = this.parseDescription();\r\n    const name = this.parseEnumValueName();\r\n    const directives = this.parseConstDirectives();\r\n    return this.node(start, {\r\n      kind: Kind.ENUM_VALUE_DEFINITION,\r\n      description,\r\n      name,\r\n      directives,\r\n    });\r\n  }\r\n  /**\r\n   * EnumValue : Name but not `true`, `false` or `null`\r\n   */\r\n\r\n  parseEnumValueName() {\r\n    if (\r\n      this._lexer.token.value === 'true' ||\r\n      this._lexer.token.value === 'false' ||\r\n      this._lexer.token.value === 'null'\r\n    ) {\r\n      throw syntaxError(\r\n        this._lexer.source,\r\n        this._lexer.token.start,\r\n        `${getTokenDesc(\r\n          this._lexer.token,\r\n        )} is reserved and cannot be used for an enum value.`,\r\n      );\r\n    }\r\n\r\n    return this.parseName();\r\n  }\r\n  /**\r\n   * InputObjectTypeDefinition :\r\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\r\n   */\r\n\r\n  parseInputObjectTypeDefinition() {\r\n    const start = this._lexer.token;\r\n    const description = this.parseDescription();\r\n    this.expectKeyword('input');\r\n    const name = this.parseName();\r\n    const directives = this.parseConstDirectives();\r\n    const fields = this.parseInputFieldsDefinition();\r\n    return this.node(start, {\r\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\r\n      description,\r\n      name,\r\n      directives,\r\n      fields,\r\n    });\r\n  }\r\n  /**\r\n   * ```\r\n   * InputFieldsDefinition : { InputValueDefinition+ }\r\n   * ```\r\n   */\r\n\r\n  parseInputFieldsDefinition() {\r\n    return this.optionalMany(\r\n      TokenKind.BRACE_L,\r\n      this.parseInputValueDef,\r\n      TokenKind.BRACE_R,\r\n    );\r\n  }\r\n  /**\r\n   * TypeSystemExtension :\r\n   *   - SchemaExtension\r\n   *   - TypeExtension\r\n   *\r\n   * TypeExtension :\r\n   *   - ScalarTypeExtension\r\n   *   - ObjectTypeExtension\r\n   *   - InterfaceTypeExtension\r\n   *   - UnionTypeExtension\r\n   *   - EnumTypeExtension\r\n   *   - InputObjectTypeDefinition\r\n   */\r\n\r\n  parseTypeSystemExtension() {\r\n    const keywordToken = this._lexer.lookahead();\r\n\r\n    if (keywordToken.kind === TokenKind.NAME) {\r\n      switch (keywordToken.value) {\r\n        case 'schema':\r\n          return this.parseSchemaExtension();\r\n\r\n        case 'scalar':\r\n          return this.parseScalarTypeExtension();\r\n\r\n        case 'type':\r\n          return this.parseObjectTypeExtension();\r\n\r\n        case 'interface':\r\n          return this.parseInterfaceTypeExtension();\r\n\r\n        case 'union':\r\n          return this.parseUnionTypeExtension();\r\n\r\n        case 'enum':\r\n          return this.parseEnumTypeExtension();\r\n\r\n        case 'input':\r\n          return this.parseInputObjectTypeExtension();\r\n      }\r\n    }\r\n\r\n    throw this.unexpected(keywordToken);\r\n  }\r\n  /**\r\n   * ```\r\n   * SchemaExtension :\r\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\r\n   *  - extend schema Directives[Const]\r\n   * ```\r\n   */\r\n\r\n  parseSchemaExtension() {\r\n    const start = this._lexer.token;\r\n    this.expectKeyword('extend');\r\n    this.expectKeyword('schema');\r\n    const directives = this.parseConstDirectives();\r\n    const operationTypes = this.optionalMany(\r\n      TokenKind.BRACE_L,\r\n      this.parseOperationTypeDefinition,\r\n      TokenKind.BRACE_R,\r\n    );\r\n\r\n    if (directives.length === 0 && operationTypes.length === 0) {\r\n      throw this.unexpected();\r\n    }\r\n\r\n    return this.node(start, {\r\n      kind: Kind.SCHEMA_EXTENSION,\r\n      directives,\r\n      operationTypes,\r\n    });\r\n  }\r\n  /**\r\n   * ScalarTypeExtension :\r\n   *   - extend scalar Name Directives[Const]\r\n   */\r\n\r\n  parseScalarTypeExtension() {\r\n    const start = this._lexer.token;\r\n    this.expectKeyword('extend');\r\n    this.expectKeyword('scalar');\r\n    const name = this.parseName();\r\n    const directives = this.parseConstDirectives();\r\n\r\n    if (directives.length === 0) {\r\n      throw this.unexpected();\r\n    }\r\n\r\n    return this.node(start, {\r\n      kind: Kind.SCALAR_TYPE_EXTENSION,\r\n      name,\r\n      directives,\r\n    });\r\n  }\r\n  /**\r\n   * ObjectTypeExtension :\r\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\r\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\r\n   *  - extend type Name ImplementsInterfaces\r\n   */\r\n\r\n  parseObjectTypeExtension() {\r\n    const start = this._lexer.token;\r\n    this.expectKeyword('extend');\r\n    this.expectKeyword('type');\r\n    const name = this.parseName();\r\n    const interfaces = this.parseImplementsInterfaces();\r\n    const directives = this.parseConstDirectives();\r\n    const fields = this.parseFieldsDefinition();\r\n\r\n    if (\r\n      interfaces.length === 0 &&\r\n      directives.length === 0 &&\r\n      fields.length === 0\r\n    ) {\r\n      throw this.unexpected();\r\n    }\r\n\r\n    return this.node(start, {\r\n      kind: Kind.OBJECT_TYPE_EXTENSION,\r\n      name,\r\n      interfaces,\r\n      directives,\r\n      fields,\r\n    });\r\n  }\r\n  /**\r\n   * InterfaceTypeExtension :\r\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\r\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\r\n   *  - extend interface Name ImplementsInterfaces\r\n   */\r\n\r\n  parseInterfaceTypeExtension() {\r\n    const start = this._lexer.token;\r\n    this.expectKeyword('extend');\r\n    this.expectKeyword('interface');\r\n    const name = this.parseName();\r\n    const interfaces = this.parseImplementsInterfaces();\r\n    const directives = this.parseConstDirectives();\r\n    const fields = this.parseFieldsDefinition();\r\n\r\n    if (\r\n      interfaces.length === 0 &&\r\n      directives.length === 0 &&\r\n      fields.length === 0\r\n    ) {\r\n      throw this.unexpected();\r\n    }\r\n\r\n    return this.node(start, {\r\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\r\n      name,\r\n      interfaces,\r\n      directives,\r\n      fields,\r\n    });\r\n  }\r\n  /**\r\n   * UnionTypeExtension :\r\n   *   - extend union Name Directives[Const]? UnionMemberTypes\r\n   *   - extend union Name Directives[Const]\r\n   */\r\n\r\n  parseUnionTypeExtension() {\r\n    const start = this._lexer.token;\r\n    this.expectKeyword('extend');\r\n    this.expectKeyword('union');\r\n    const name = this.parseName();\r\n    const directives = this.parseConstDirectives();\r\n    const types = this.parseUnionMemberTypes();\r\n\r\n    if (directives.length === 0 && types.length === 0) {\r\n      throw this.unexpected();\r\n    }\r\n\r\n    return this.node(start, {\r\n      kind: Kind.UNION_TYPE_EXTENSION,\r\n      name,\r\n      directives,\r\n      types,\r\n    });\r\n  }\r\n  /**\r\n   * EnumTypeExtension :\r\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\r\n   *   - extend enum Name Directives[Const]\r\n   */\r\n\r\n  parseEnumTypeExtension() {\r\n    const start = this._lexer.token;\r\n    this.expectKeyword('extend');\r\n    this.expectKeyword('enum');\r\n    const name = this.parseName();\r\n    const directives = this.parseConstDirectives();\r\n    const values = this.parseEnumValuesDefinition();\r\n\r\n    if (directives.length === 0 && values.length === 0) {\r\n      throw this.unexpected();\r\n    }\r\n\r\n    return this.node(start, {\r\n      kind: Kind.ENUM_TYPE_EXTENSION,\r\n      name,\r\n      directives,\r\n      values,\r\n    });\r\n  }\r\n  /**\r\n   * InputObjectTypeExtension :\r\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\r\n   *   - extend input Name Directives[Const]\r\n   */\r\n\r\n  parseInputObjectTypeExtension() {\r\n    const start = this._lexer.token;\r\n    this.expectKeyword('extend');\r\n    this.expectKeyword('input');\r\n    const name = this.parseName();\r\n    const directives = this.parseConstDirectives();\r\n    const fields = this.parseInputFieldsDefinition();\r\n\r\n    if (directives.length === 0 && fields.length === 0) {\r\n      throw this.unexpected();\r\n    }\r\n\r\n    return this.node(start, {\r\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\r\n      name,\r\n      directives,\r\n      fields,\r\n    });\r\n  }\r\n  /**\r\n   * ```\r\n   * DirectiveDefinition :\r\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\r\n   * ```\r\n   */\r\n\r\n  parseDirectiveDefinition() {\r\n    const start = this._lexer.token;\r\n    const description = this.parseDescription();\r\n    this.expectKeyword('directive');\r\n    this.expectToken(TokenKind.AT);\r\n    const name = this.parseName();\r\n    const args = this.parseArgumentDefs();\r\n    const repeatable = this.expectOptionalKeyword('repeatable');\r\n    this.expectKeyword('on');\r\n    const locations = this.parseDirectiveLocations();\r\n    return this.node(start, {\r\n      kind: Kind.DIRECTIVE_DEFINITION,\r\n      description,\r\n      name,\r\n      arguments: args,\r\n      repeatable,\r\n      locations,\r\n    });\r\n  }\r\n  /**\r\n   * DirectiveLocations :\r\n   *   - `|`? DirectiveLocation\r\n   *   - DirectiveLocations | DirectiveLocation\r\n   */\r\n\r\n  parseDirectiveLocations() {\r\n    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);\r\n  }\r\n  /*\r\n   * DirectiveLocation :\r\n   *   - ExecutableDirectiveLocation\r\n   *   - TypeSystemDirectiveLocation\r\n   *\r\n   * ExecutableDirectiveLocation : one of\r\n   *   `QUERY`\r\n   *   `MUTATION`\r\n   *   `SUBSCRIPTION`\r\n   *   `FIELD`\r\n   *   `FRAGMENT_DEFINITION`\r\n   *   `FRAGMENT_SPREAD`\r\n   *   `INLINE_FRAGMENT`\r\n   *\r\n   * TypeSystemDirectiveLocation : one of\r\n   *   `SCHEMA`\r\n   *   `SCALAR`\r\n   *   `OBJECT`\r\n   *   `FIELD_DEFINITION`\r\n   *   `ARGUMENT_DEFINITION`\r\n   *   `INTERFACE`\r\n   *   `UNION`\r\n   *   `ENUM`\r\n   *   `ENUM_VALUE`\r\n   *   `INPUT_OBJECT`\r\n   *   `INPUT_FIELD_DEFINITION`\r\n   */\r\n\r\n  parseDirectiveLocation() {\r\n    const start = this._lexer.token;\r\n    const name = this.parseName();\r\n\r\n    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {\r\n      return name;\r\n    }\r\n\r\n    throw this.unexpected(start);\r\n  } // Core parsing utility functions\r\n\r\n  /**\r\n   * Returns a node that, if configured to do so, sets a \"loc\" field as a\r\n   * location object, used to identify the place in the source that created a\r\n   * given parsed object.\r\n   */\r\n\r\n  node(startToken, node) {\r\n    if (this._options.noLocation !== true) {\r\n      node.loc = new Location(\r\n        startToken,\r\n        this._lexer.lastToken,\r\n        this._lexer.source,\r\n      );\r\n    }\r\n\r\n    return node;\r\n  }\r\n  /**\r\n   * Determines if the next token is of a given kind\r\n   */\r\n\r\n  peek(kind) {\r\n    return this._lexer.token.kind === kind;\r\n  }\r\n  /**\r\n   * If the next token is of the given kind, return that token after advancing the lexer.\r\n   * Otherwise, do not change the parser state and throw an error.\r\n   */\r\n\r\n  expectToken(kind) {\r\n    const token = this._lexer.token;\r\n\r\n    if (token.kind === kind) {\r\n      this.advanceLexer();\r\n      return token;\r\n    }\r\n\r\n    throw syntaxError(\r\n      this._lexer.source,\r\n      token.start,\r\n      `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`,\r\n    );\r\n  }\r\n  /**\r\n   * If the next token is of the given kind, return \"true\" after advancing the lexer.\r\n   * Otherwise, do not change the parser state and return \"false\".\r\n   */\r\n\r\n  expectOptionalToken(kind) {\r\n    const token = this._lexer.token;\r\n\r\n    if (token.kind === kind) {\r\n      this.advanceLexer();\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n  /**\r\n   * If the next token is a given keyword, advance the lexer.\r\n   * Otherwise, do not change the parser state and throw an error.\r\n   */\r\n\r\n  expectKeyword(value) {\r\n    const token = this._lexer.token;\r\n\r\n    if (token.kind === TokenKind.NAME && token.value === value) {\r\n      this.advanceLexer();\r\n    } else {\r\n      throw syntaxError(\r\n        this._lexer.source,\r\n        token.start,\r\n        `Expected \"${value}\", found ${getTokenDesc(token)}.`,\r\n      );\r\n    }\r\n  }\r\n  /**\r\n   * If the next token is a given keyword, return \"true\" after advancing the lexer.\r\n   * Otherwise, do not change the parser state and return \"false\".\r\n   */\r\n\r\n  expectOptionalKeyword(value) {\r\n    const token = this._lexer.token;\r\n\r\n    if (token.kind === TokenKind.NAME && token.value === value) {\r\n      this.advanceLexer();\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n  /**\r\n   * Helper function for creating an error when an unexpected lexed token is encountered.\r\n   */\r\n\r\n  unexpected(atToken) {\r\n    const token =\r\n      atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\r\n    return syntaxError(\r\n      this._lexer.source,\r\n      token.start,\r\n      `Unexpected ${getTokenDesc(token)}.`,\r\n    );\r\n  }\r\n  /**\r\n   * Returns a possibly empty list of parse nodes, determined by the parseFn.\r\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\r\n   * Advances the parser to the next lex token after the closing token.\r\n   */\r\n\r\n  any(openKind, parseFn, closeKind) {\r\n    this.expectToken(openKind);\r\n    const nodes = [];\r\n\r\n    while (!this.expectOptionalToken(closeKind)) {\r\n      nodes.push(parseFn.call(this));\r\n    }\r\n\r\n    return nodes;\r\n  }\r\n  /**\r\n   * Returns a list of parse nodes, determined by the parseFn.\r\n   * It can be empty only if open token is missing otherwise it will always return non-empty list\r\n   * that begins with a lex token of openKind and ends with a lex token of closeKind.\r\n   * Advances the parser to the next lex token after the closing token.\r\n   */\r\n\r\n  optionalMany(openKind, parseFn, closeKind) {\r\n    if (this.expectOptionalToken(openKind)) {\r\n      const nodes = [];\r\n\r\n      do {\r\n        nodes.push(parseFn.call(this));\r\n      } while (!this.expectOptionalToken(closeKind));\r\n\r\n      return nodes;\r\n    }\r\n\r\n    return [];\r\n  }\r\n  /**\r\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\r\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\r\n   * Advances the parser to the next lex token after the closing token.\r\n   */\r\n\r\n  many(openKind, parseFn, closeKind) {\r\n    this.expectToken(openKind);\r\n    const nodes = [];\r\n\r\n    do {\r\n      nodes.push(parseFn.call(this));\r\n    } while (!this.expectOptionalToken(closeKind));\r\n\r\n    return nodes;\r\n  }\r\n  /**\r\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\r\n   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.\r\n   * Advances the parser to the next lex token after last item in the list.\r\n   */\r\n\r\n  delimitedMany(delimiterKind, parseFn) {\r\n    this.expectOptionalToken(delimiterKind);\r\n    const nodes = [];\r\n\r\n    do {\r\n      nodes.push(parseFn.call(this));\r\n    } while (this.expectOptionalToken(delimiterKind));\r\n\r\n    return nodes;\r\n  }\r\n\r\n  advanceLexer() {\r\n    const { maxTokens } = this._options;\r\n\r\n    const token = this._lexer.advance();\r\n\r\n    if (maxTokens !== undefined && token.kind !== TokenKind.EOF) {\r\n      ++this._tokenCounter;\r\n\r\n      if (this._tokenCounter > maxTokens) {\r\n        throw syntaxError(\r\n          this._lexer.source,\r\n          token.start,\r\n          `Document contains more that ${maxTokens} tokens. Parsing aborted.`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n/**\r\n * A helper function to describe a token as a string for debugging.\r\n */\r\n\r\nfunction getTokenDesc(token) {\r\n  const value = token.value;\r\n  return getTokenKindDesc(token.kind) + (value != null ? ` \"${value}\"` : '');\r\n}\r\n/**\r\n * A helper function to describe a token kind as a string for debugging.\r\n */\r\n\r\nfunction getTokenKindDesc(kind) {\r\n  return isPunctuatorTokenKind(kind) ? `\"${kind}\"` : kind;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}